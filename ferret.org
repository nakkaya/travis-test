#+title: Ferret Programmer's Manual
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+SETUPFILE: org-mode-assets/org-mode.setup
#+OPTIONS: H:10

* Getting Started
** What Is Ferret

Ferret is a free software Clojure implementation, it compiles a
restricted subset of the Clojure language to self contained *ISO
C++11* which allows for the use of Clojure in real time embedded
control systems. 

Generated code is self contained *ISO C++11*, it is not tied to any
one compiler, generated code should be portable between any Operating
System and/or Microcontroller that supports a *C++11* compliant
compiler. It has been verified to run on architectures ranging from
embedded systems with as little as *2KB of RAM* to general purpose
computers running Linux/Mac OS X/Windows.

 - General Purpose Computers
   - Clang on Mac OS X
   - GCC & Clang on Linux
 - Microcontrollers
   - Arduino 
     - Uno / Atmega328
     - Due / AT91SAM3X8E
     - 101 / Intel Curie
   - Teensy
     - 3.2 / Cortex-M4
     - 3.6 / Cortex-M4F
   - SparkFun SAMD21 Mini / ATSAMD21G18 - ARM Cortex-M0+
 - [[Hardware / Operating System Support]]

** Features

 - Tailored for Real Time Control Applications. (Deterministic Execution.)
 - Immutable Data Structures
 - Functional
 - Macros
 - Easy FFI (Inline C,C++. See [[Accessing C,C++ Libraries]])
 - Easily Embeddable (i.e Ferret fns are just C++ functors.)
 - Memory Pooling (Ability to *run without heap memory*. See [[Memory Management]])
 - Destructuring
 - Module System

** Download

Ferret is available as prebuilt and source code distributions. See
[[Building From Sources]] for links to source distribution.

#+BEGIN_HTML
  <img src="https://badge.fury.io/gh/nakkaya%2Fferret.svg" style="float: left; padding-right: 1cm;">
  <img src="https://travis-ci.org/nakkaya/ferret.svg?branch=master" style="margin-left: 0;">
#+END_HTML

   - [[http://ferret-lang.org/builds/ferret][Executable]] (Requires Bash and JVM)
   - [[http://ferret-lang.org/builds/ferret.jar][Standalone Jar]] (Requires JVM)

** A glimpse of Ferret

On any system, we can just compile a program directly into an
executable. Here's a program that sums the first 5 positive numbers.

#+begin_src clojure
  ;;; lazy-sum.clj
  (defn positive-numbers
    ([]
     (positive-numbers 1))
    ([n]
     (cons n (lazy-seq (positive-numbers (inc n))))))

  (println (->> (positive-numbers)
                (take 5)
                (apply +)))
#+end_src

We can compile this program using *ferret*, creating an executable named
*a.out*.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj
  $ g++ -std=c++11 -pthread lazy-sum.cpp
  $ ./a.out
  15
#+END_EXAMPLE

Output will be placed in a a file called *lazy-sum.cpp*. When *-c*
flag is used ferret will call *g++* or if set *CXX* environment
variable on the resulting *cpp* file.

#+BEGIN_EXAMPLE
  $ ./ferret -i lazy-sum.clj -c
  $ ./a.out
  15
#+END_EXAMPLE

Following shows a blink example for Arduino. (See section [[Arduino
Boards]] for more info on how to use Ferret lisp on Arduino boards.) 

#+begin_src clojure
  ;;; blink.clj
  (pin-mode 13 :output)

  (forever
   (digital-write 13 1)
   (sleep 500)
   (digital-write 13 0)
   (sleep 500))
#+end_src

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj
  $ mkdir blink
  $ mv blink.cpp blink/blink.ino
#+END_EXAMPLE

Then upload as usual. Following is another example, showing the usage
of [[Memory Pooling]]. Program will blink two LEDs simultaneously at
different frequencies (Yellow LED at 5 hz Blue LED at 20 hz). It uses
a memory pool of 512 bytes allocated at compile time instead of
calling malloc/free at runtime.

#+begin_src clojure
  (configure-ferret! :command "mv ferret-multi-led.cpp ferret-multi-led.ino")

  (configure-runtime! FERRET_MEMORY_POOL_SIZE 512
                      FERRET_MEMORY_POOL_PAGE_TYPE char)

  (def yellow-led 13)
  (def blue-led   12)

  (pin-mode yellow-led :output)
  (pin-mode blue-led   :output)

  (defn make-led-toggler [pin]
    (fn []
      (->> (digital-read pin)
           (bit-xor 1)
           (digital-write pin))))

  (def job-one
    (fn-throttler (make-led-toggler yellow-led) 5 :second :non-blocking))

  (def job-two
    (fn-throttler (make-led-toggler blue-led)  20 :second :non-blocking))

  (forever
   (job-one)
   (job-two))
#+end_src

** Support

 - [[https://groups.google.com/forum/#!forum/ferret-lang][ferret-lang]] - Mailing List

** Examples
*** Projects

 - [[https://nakkaya.com/2017/02/15/bare-metal-lisp-rc-control-using-ferret/][Bare Metal Lisp - RC Control using Ferret]]
 - [[http://nakkaya.com/2016/06/10/ferret-a-hard-real-time-clojure-for-lisp-machines/][Ferret - A Hard Real-Time Clojure for Lisp Machines]] -
   Implementation of a line following robot in Ferret.
 - [[https://git.nakkaya.com/nakkaya/solarcar-tracker][solarcar-tracker]] - A Tracking device for the [[http://solarcar.neu.edu.tr][Ra27 solar car]]. (GPS,
   IMU etc.) (Raspberry Pi)
 - [[https://git.nakkaya.com/nakkaya/solarcar-turn-indicator/tree/master][solarcar-turn-indicator]] - Controller for the turn indicator
   assembly on the [[http://solarcar.neu.edu.tr][Ra27 solar car]]. (Atmega MCU)
 - [[https://git.nakkaya.com/nakkaya/ferret-qt-hello-world][ferret-qt-hello-world]] - QT Hello World FFI Example in Ferret Lisp

*** Wrappers

 - [[https://git.nakkaya.com/nakkaya/ferret-opencv][ferret-opencv]] - Ferret bindings for OpenCV
 - [[https://git.nakkaya.com/nakkaya/ferret-genann][ferret-genann]] - Ferret bindings for [[https://codeplea.com/genann][genann]] - simple neural
   network library in ANSI C.
 - [[https://git.nakkaya.com/nakkaya/ferret-teensy-flight-sim][ferret-teensy-flight-sim]] - Wrapper for Teensy flight sim controls.
 - [[https://git.nakkaya.com/nakkaya/ferret-arduino-keypad][ferret-arduino-keypad]] - Arduino Keypad library bindings.
 - [[https://git.nakkaya.com/nakkaya/ferret-arduino-adafruit-pcd8544][ferret-arduino-adafruit-pcd8544]] - Adafruit Arduino PCD8544 screen
   library bindings most commonly found in Nokia 5110.
 - [[https://git.nakkaya.com/nakkaya/ferret-boost][ferret-boost]] - Boost bindings.
 - [[https://git.nakkaya.com/nakkaya/ferret-websocket][ferret-websocket]] - WebSocket++ bindigns.
 - [[https://git.nakkaya.com/nakkaya/ferret-logging][ferret-logging]] - easyloggingpp bindigns.
 - [[https://git.nakkaya.com/nakkaya/ferret-great-circle-navigation][ferret-great-circle-navigation]] - Utils for great circle
   navigation.

** License

BSD 2-Clause License

Copyright (c) 2017, Nurullah Akkaya
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

* Overview

Ferret is a functional, lazy language. All functions should mimic
their Clojure counter parts. If they don't it is considered a bug. (or
not possible to implement with the current implementation.)

This document is not intended to be a full Clojure tutorial. It is a
specification of the subset of Clojure implemented by Ferret, and
the particular workings of the Object / Runtime system.

** Documentation Structure

This is a literate program, inspired by Donald Knuth (Knuth, Donald
“Literate Programming (1984)” Literate Programming CSLI, p99). It is
intended to be read like a novel from cover to cover. The ideas are
expressed clearly but they are grounded in the actual source code.

The compiler and the C++ runtime needed is split into three sections.

 - [[Compiler]]
 - [[Native Core]]
 - [[Clojure Core]]

*[[Compiler]]* section contains the actual compiler written in Clojure. It
takes the Clojure code and converts it to a Intermediate
representation by taking the Clojure form and running it [[Compilation][through some
transformations]]. This IR is then run through [[Code Generation]] module to
create C++ code. *[[Native Core]]* contains the C++ runtime needed to
support Ferret such as [[Object System]], [[Memory Pool][ Memory Pooling]], [[Reference Counting][Garbage
Collection]]. It is written in a mixture of C++ and Ferret DSL. *[[Clojure
Core]]* corresponds to *clojure.core*, contains all Clojure functions
supported by Ferret.

** Hardware / Operating System Support

Ferret does not depend on any external dependencies (Including the C++
Standard Library). Unit tests are run on Mac OS X and Linux, any
operating system with a C++11 compiler is supported. When running on a
microcontroller ferret will check if it is a supported platform during
compile time and enable hardware specific features. (Currently only
UART is hardware specific.) If running on an unknown hardware it
will run in *safe mode* (UART disabled.). Everything else is supported
in safe mode. Like operating system support any embedded system with a
C++11 compiler is supported. See [[What Is Ferret]] for a list of
currently supported microcontrollers.

*** Arduino Boards

Ferret standard library has built in support for Arduino library. *Any
board* that Arduino IDE supports should work with Ferret lisp. 

*Post Arduino 1.5.0*, Ferret compiler can upload directly to a Arduino
board by adding the following build command to the top of the file,

#+begin_src clojure
  (configure-ferret! :command "~/apps/arduino-1.8.0/arduino \\
                                 --board arduino:sam:arduino_due_x_dbg \\
                                 --port /dev/ttyACM0 \\
                                 --upload ./blink.cpp")
#+end_src

When *-c* option is passed Ferret will execute the above command and
upload the solution to the board. (See [[https://github.com/arduino/Arduino/blob/master/build/shared/manpage.adoc][ARDUINO(1) Manual Page]] for
details.)

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj -c
#+END_EXAMPLE

*Pre Arduino 1.5.0*, recommended way is to go to preferences and set
Arduino IDE to use an External Editor. This way when Ferret recompiles
the sketch changes will be automatically picked up by the IDE ready to
be uploaded. To automatically rename the *cpp* file to *ino* or *pde*
use the following option,

#+begin_src clojure
  (configure-ferret! :command "mv blink.cpp blink.ino")
#+end_src

Then compile with,

#+BEGIN_EXAMPLE
  $ ./ferret -i blink.clj -c
#+END_EXAMPLE

Result will be *blink.ino* ready to be uploaded. Any changes to the
*clj* file should be picked up by the IDE.

** Building From Sources

The code in this document is the executable source. Use the *build*
script in the source distribution to extract source code.

The latest sources are available at,

  - [[https://git.nakkaya.com/nakkaya/ferret][git.nakkaya.com]]
  - [[https://github.com/nakkaya/ferret][Github]]

Dependencies,

 - Java
 - Emacs >= 24.5
 - Clojure
 - Leiningen

Assuming all of the above is in your path just run,

#+BEGIN_EXAMPLE
  ./build
#+END_EXAMPLE

This will extract the source from this file to *src/* directory and
build the *jar* and *executable* distributions. *build* script assumes
it is running on a **NIX* based system if not, open this file using
*emacs* and run,

#+BEGIN_EXAMPLE
  M-x org-babel-tangle
#+END_EXAMPLE

that will extract the source code then you can threat it as any other
Clojure/Lein project.

* Compiler

Ferret has a similar architecture to other modern compilers,

#+CAPTION: Ferret Compiler Architecture
#+NAME:   fig:compiler_architecture
[[./ferret-styles/graphs/compiler_arch.png]]

First, an input file containing Clojure code is loaded from the
command line. From there a series of source-to-source transformations
are performed on the AST to expand macros, perform optimizations, and
make the code easier to compile to C++. (Optionally these intermediate
representations (IR) can be printed out in a readable format to aid
debugging.) The final AST is then output as a .cpp file and the C++
compiler is invoked to create the final executable or object file.

** Compilation

Clojure (or any other Lisp) has features not provided by C++ such as
automatic memory management i.e. garbage collection (GC), closures
etc. Source-to-source transformations are used to add constructs
required by C++, restructure Clojure forms in preparation to generate
C++ code. Final intermediate representation can be directly compiled
to C++. Any Clojure form go through nine transformations before they
are passed to the code generation phase. Each transformation makes a
separate pass over the form, this makes the compiler easier to
maintain.

#+name: core-compilation-process
#+begin_src clojure :tangle no
  (defn compile [form options]
    (->> (ferret-runtime form options)
         (remove-assertions options)
         (expand-macros-all)
         (let->fn)
         (do->fn)
         (closure-conversion)
         (replace-fn-call-sites options)
         (escape-analysis)
         (symbol-conversion)))
#+end_src

*** Runtime

Generates the required runtime for the form by importing the required
modules and concatenate the required runtime from clojure.core
(src/ferret/runtime.clj)

#+name: core-compilation-embed-ferret-runtime
#+begin_src clojure :tangle no
  (defn ferret-runtime [form options]
    (->> (import-modules-all form options)
         (shake-concat (read-clojure-file-from-url "ferret/runtime.clj"))
         ;; tag form with the build info
         (cons `(~'native-define ~(try
                                    (let [version (read-from-url "build.info")]
                                      (str "// ferret-lisp build:" version))
                                    (catch Exception e
                                      (str "// ferret-lisp")))))))
#+end_src

Import other ferret files using,

#+BEGIN_SRC clojure :tangle no
  (require 'package.io)

  (require '[package.io :as io])

  (require '[package.io :as io]
           '[package.udp :as udp])
#+END_SRC

Compiler will look for a file under current working directory called,
/package/io.clj/ all expression in the that file will be added to the
front of the current form with symbols renamed to /some-fn/ =>
/io/some-function/.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules-select-require [form]
    (let [norm-require (fn [f]
                         (if (symbol? f)
                           [f :as f]
                           f))]
      (->> (select-form form (is-form? 'require))
           (reduce (fn[h v]
                     (if (= 2 (count v))
                       ;; require single module
                       (conj h (norm-require (->> v last last)))
                       ;; require multiple modules
                       (concat h (map #(norm-require (last %)) (rest v))))) [])
           (map (fn [[mod _ as]] [mod as]))
           (reduce (fn[h [mod as]]
                     (if (h mod)
                       (assoc h mod (conj (h mod) as))
                       (assoc h mod [as]))) {}))))
#+end_src

Extract the list of packages and aliases from the form. Returns a map
of mod -> aliases pairs.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules-load-modules [package-list options]
    (reduce (fn[h [m aliases]]
              (let [mod (-> (str (:path options) (.replace (str m) "." "/") ".clj")
                            (read-clojure-file)
                            (remove-form (is-form? 'configure-runtime!))
                            (remove-form (is-form? 'configure-ferret!)))
                    macro-symbols (->> (select-form mod (is-form? 'defmacro))
                                       (map second)
                                       (into #{}))
                    def-symbols (->> (select-form (expand-macros-all mod) (is-form? 'def))
                                     (map second)
                                     (into #{}))
                    replace? (set/union macro-symbols def-symbols)
                    mod (morph-form mod #(and (symbol? %)
                                              (replace? %))
                                    #(symbol (str (.replace (str m) "." "_") "_" %)))]
                (reduce (fn [h v] (conj h v)) h mod)))
            (list ) package-list))
#+end_src

Loads all modules listed in the package list. When a module is loaded
all its symbols are replaced with its module name except /core/
functions. Module names acts as namespaces. Returns a form that the is
concatenation of all modules listed in form.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules-convert-alias-to-module [package-list form]
    (let [alias-to-mod (reduce (fn[h [mod aliases]]
                                 (reduce (fn[h v] (assoc h v mod)) h aliases))
                               {} package-list)
          form (morph-form form symbol?
                           (fn [f]
                             (if-let [[_ alias fn] (re-find #"(.*?)/(.*)" (str f))]
                               (if-let [mod-sym (alias-to-mod (symbol alias))]
                                 (symbol (str (.replace (str mod-sym) "." "_") "_" fn))
                                 f)
                               f)))]
      form))
#+end_src

Convert all aliased symbols in the form to their fully qualified
modules names. So =helper-a= defined in module =util.db= becomes
=util_db_helper-a=.

#+name: core-compilation-embed-ferret-core
#+begin_src clojure :tangle no
  (defn import-modules [form options]
    (let [package-list (import-modules-select-require form)
          form (remove-form form (is-form? 'require))
          modules (import-modules-load-modules package-list options)
          form (import-modules-convert-alias-to-module package-list form)]
      (shake-concat modules form)))

  (defn import-modules-all [form options]
    (loop [f form]
      (let [expanded (import-modules f options)]
        (if (= f expanded)
          expanded
          (recur expanded)))))
#+end_src

Import all modules in the given form.

*** Expand Macros

Process some supported reader macros, /@/ and /#(some-fn)/ forms.

#+name: core-compilation-expand-macros
#+begin_src clojure :tangle no
  (defn expand-reader-macros [form]
    (morph-form form
                (is-form? 'clojure.core/deref)
                (fn [f] `(~'deref ~@(rest f)))))
#+end_src

Macro expansion is done by reading all the macros present in
src/ferret/runtime.clj and combining them with user defined macros. They
are evaluated in a temporary namespace, using /morph-form/ we iterate
all the macros used in the code that we are compiling and expand them
in the temporary namespace then the node is replaced with its expanded
form.

#+name: core-compilation-expand-macros
#+begin_src clojure :tangle no
  (declare expand-macros-all)

  (defn expand-macros [form]
    (let [core-macros (->> (read-clojure-file-from-url "ferret/runtime.clj")
                           (filter (is-form? 'defmacro)))
          core-macro-symbols (into #{} (map second core-macros))
          form-macros (->> (filter (is-form? 'defmacro) form)
                           (filter (fn [[_ name]]
                                     (not (core-macro-symbols name)))))
          form-macro-symbols (map second form-macros)
          form (remove-form form (is-form? 'defmacro))
          temp-ns (gensym)
          macro-symbols (concat core-macro-symbols form-macro-symbols)]
      
      (create-ns temp-ns)
      (binding [*ns* (the-ns temp-ns)]
        (refer 'clojure.core :exclude (concat macro-symbols ['fn 'def]))
        (use '[ferret.core :only [symbol-conversion unique-fn]])
        
        (doseq [m (concat core-macros form-macros)]
          (eval m)))
      
      (let [form (-> form
                     (macro-normalize)
                     (expand-reader-macros)
                     (morph-form (apply is-form? macro-symbols)
                                 (fn [f]
                                   (binding [*ns* (the-ns temp-ns)]
                                     (walk/macroexpand-all f)))))]
        (remove-ns temp-ns)
        form)))

  (defn expand-macros-all-aux [form]
    (loop [f form]
      (let [expanded (expand-macros f)]
        (if (= f expanded)
          expanded
          (recur expanded)))))

  (def expand-macros-all (memoize expand-macros-all-aux))
#+end_src

Prepare form /f/ for macro expansion,

#+name: core-compilation-normalize
#+begin_src clojure :tangle no
  (defn macro-normalize [f]
    (morph-form f
                (is-form? 'let)
                (fn [[_ bindings & body]]
                  `(~'let* ~(apply list bindings) ~@body))))
#+end_src

Takes a *fn* form and converts all argument symbols with their unique
replacements,

#+begin_src clojure
  (fn [a b] (list a b))
  ;;becomes
  (fn [a__1510 b__1511] (list a__1510 b__1511))
#+end_src

#+name: core-compilation-unique-fn
#+begin_src clojure :tangle no
  (defn unique-fn [form]
    (let [valid-symbol? (fn [s] (and (not= s '&) (not= s '_)))
          [args & body] form]
      (if (string? (first body))
        `(~'fn* ~args ~@body)
        (let [unique-args (->> args
                               flatten
                               (filter valid-symbol?)
                               (map #(symbol (str % (gensym "__")))))
              replace? (->> (interleave (->> args
                                             flatten
                                             (filter valid-symbol?))
                                        unique-args)
                            (apply hash-map))
              unique-body (walk/prewalk
                           (fn [x]
                             (if (and (symbol? x)
                                      (replace? x))
                               (replace? x)
                               x)) body)
              args (->> (morph-form args #(replace? %) #(replace? %))
                        (into []))]
          `(~'fn* ~args ~@unique-body)))))
#+end_src

*** let->fn

/let/ forms are transformed into nested functions which are then
called immediately, bindings are setup in the outer function,
expressions are placed in the inner function which takes the bindings
as arguments.

So following form,

#+begin_src clojure :tangle no
  (let->fn '(let [a 1
                  b 2]
              (+ a b)))
#+end_src

after transformation becomes,

#+begin_src clojure :tangle no
  (define_lambda G__2708 (b a) () (_plus_ a b))
  (define_lambda G__2709 (a) (b) ((lambda_object G__2708 b a)))
  (define_lambda G__2710 () (a) ((lambda_object G__2709 a) 2))
  ((lambda_object G__2710) 1)
#+end_src

#+name: core-compilation-let-fn
#+begin_src clojure :tangle no
  (defn let->fn [form]
    (-> form

        (morph-form (is-form? 'let*)
                    (fn [[_ bindings & body]]
                      (if (empty? bindings)
                        `((~'fn () ~@body))
                        (apply
                         (fn close [[arg val] & more]
                           (if (empty? more)
                             `((~'fn [~arg] ~@body) ~val)
                             `((~'fn [~arg] ~(apply close more)) ~val)))
                         (partition 2 bindings)))))

        (morph-form (is-form? 'fn)
                    (fn [[_ & body]]
                      (unique-fn body)))))
#+end_src

*** do->fn

A similar method is used for the do form, expressions are wrapped in a fn
that takes no parameters and executed in place.

#+begin_src clojure :tangle no
  (do->fn '(do (+ 1 1)))
#+end_src

#+begin_src clojure :tangle no
  ((fn [] (+ 1 1)))
#+end_src

#+name: core-compilation-do-fn
#+begin_src clojure :tangle no
  (defn do->fn [form]
    (morph-form form
                (is-form? 'do)
                (fn [f] `((~'fn* () ~@(rest f))))))
#+end_src

*** Closure Conversion

/closure-conversion/ handles the problem of free variables. Free
variables passed to a nested function must be captured in a closure so
they can be referenced at runtime. The closure conversion
transformation modifies lambda definitions as necessary to create new
closures.

#+begin_src clojure :tangle no
  (defn make-adder [x]
    (fn [n] (+ x n)))
#+end_src

in the above snippet /x/ is a free variable, when the function
/make-adder/ returns, it needs to have a way of referencing that
variable when it is used. The way Ferret handles this is that, every
function will pass its arguments to inner functions (if any) it
contains.

#+begin_src clojure :tangle no
  (closure-conversion '(fn [x]
                          (fn [n] (+ x n))))
#+end_src

Above form will be converted to,

#+begin_src clojure :tangle no
  (define_lambda G__3154 (x) (n) (_plus_ x n))
  (define_lambda G__3155 () (x) (lambda_object G__3154 x))
  (lambda_object G__3155)
#+end_src

What this means is, define a functor named =G__3154= that holds a
reference to /x/, and another functor =G__3155= that has no
state. When we create an instance of =G__3154= we pass /x/ to its
constructor. Since every thing is already converted to fns this
mechanism allows variables to be referenced down the line and solves
the free variable problem.

#+name: core-compilation-closure-conversion 
#+begin_src clojure :tangle no
  (defn lambda-defined? [fns env args body]
    (let [f (concat [env args] body)
          name (reduce (fn[h v]
                         (let [[_ n & r] v]
                           (if (= r f)
                             n h))) nil @fns)]
      (when name
        (apply list 'fir-lambda-object name env))))

  (defn define-lambda [fns env args body]
    (let [n (gensym)]
      (swap! fns conj (concat ['fir-define-lambda n env args] body))
      (apply list 'fir-lambda-object n env)))

  (defn closure-conversion
    ([form]
     (let [fns (atom [])
           form (closure-conversion form fns)]
       (concat form @fns)))
    ([form fns & env]
     (morph-form form
                 (is-form? 'fn*)
                 (fn [[_ args & body]]
                   (let [env (if (nil? env) '() (first env))
                         fn-env (->> args
                                     (remove #(and (seq? %)
                                                   (= 'ferret-compiler-no-closure (first %)))))
                         fn-args (->> args
                                      (map #(if (and (seq? %)
                                                     (= 'ferret-compiler-no-closure (first %)))
                                              (second %)
                                              %)))
                         body (closure-conversion body fns (concat fn-env env))]
                     (if-let [n (lambda-defined? fns env args body)]
                       n
                       (define-lambda fns env fn-args body)))))))
#+end_src

*** Symbol Conversion

Some symbols valid in Clojure are not valid C++ identifiers. This
transformation converts all symbols that are not legal C++ identifiers
into legal ones.

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn symbol-conversion [form]
    (let [c (comp #(symbol (clojure.string/escape
                            (str %)
                            {\- \_ \* "_star_" \+ "_plus_" \/ "_slash_"
                             \< "_lt_" \> "_gt_" \= "_eq_" \? "_QMARK_"
                             \! "_BANG_" \# "_"}))
                  #(cond (= 'not %) '_not_
                         :default %))]
      (morph-form form symbol? c)))
#+end_src

*** Remove Assertions

#+name: core-compilation-remove-assertions
#+begin_src clojure :tangle no
  (defn remove-assertions [options form]
    (if (:release options)
      (do (info "option => release mode")
          (remove-form form (is-form? 'assert)))
      form))
#+end_src

*** Optimizations
**** Replace Fn Call Sites

Final step replaces all functions calls with new function
objects =define_lambda= are renamed to /fn/. This removes all globals
variables unless the /fn/ defined is a closure. In which case it is
left as a global variable and the class implementation is prepended
with the global name for readability.

#+BEGIN_EXAMPLE
  (compile '((let [a 1]
               (defn adder [x]
                 (+ a x)))
             (defn my-inc [x] (+ 1 x))))

  (replace-fn-call-sites
   '((define_lambda G__3885 (a) (x) (_plus_ a x))
     (define_lambda G__3886 () (a) (def adder (lambda_object G__3885 a)))
     (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
     (define_lambda G__3888 () (x) (_plus_ 1 x))
     ((lambda_object G__3887))
     (def my_inc (lambda_object G__3888))))

  ((define_lambda adder_G__3885 (a) (x) (_plus_ a x))
   (define_lambda G__3886 () (a) (def adder (lambda_object adder_G__3885 a)))
   (define_lambda G__3887 () () (define_var a 1) ((lambda_object G__3886) a))
   (define_lambda my_inc () (x) (_plus_ 1 x))
   ((lambda_object G__3887)))
#+END_EXAMPLE

#+name: core-compilation-symbol-conversion
#+begin_src clojure :tangle no
  (defn select-def-fn [form]
    (->> (select-form form (is-form? 'def))
         (filter (fn [[_ name val]]
                   (and (seq? val)
                        (= 'fir-lambda-object (first val)))))))

  (defn replace-fn-call-sites-pure [form fn-defs fn-table]
    (let [no-global-fn (reduce (fn[h v]
                                 (remove-form h (fn [f]
                                                  (and (seq? f)
                                                       (= 'def (first f))
                                                       (every? true? (map = f v))))))
                               form fn-defs)        
          embeded-fn-calls (reduce (fn[h [name gensym]]
                                     (morph-form h  #(and (symbol? %)
                                                          (= % name))
                                                 (fn [_] (list 'fir-lambda-object gensym))))
                                   no-global-fn fn-table)
          embed-fn-names (reduce (fn[h [name gensym]]
                                   (morph-form h #(and (symbol? %)
                                                       (= % gensym))
                                               (fn [_] (identity name))))
                                 embeded-fn-calls fn-table)]
      embed-fn-names))

  (defn replace-fn-call-sites [options form]
    (if (:global-functions options)
      form
      (let [pure-fn-defs (->> (select-def-fn form)
                              (filter #(= 2 (-> % last count))))
            pure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) pure-fn-defs)
            form (replace-fn-call-sites-pure form pure-fn-defs pure-fn-table)
            closure-fn-defs (->> (select-def-fn form)
                                 (filter #(not= 2 (-> % last count))))
            closure-fn-table (map (fn [[_ name [_ gensym]]] [name gensym]) closure-fn-defs)]
        (reduce (fn[h [name gensym]]
                  (morph-form h #(and (symbol? %)
                                      (= % gensym))
                              (fn [_] (symbol (str name "_" gensym)))))
                form closure-fn-table))))
#+end_src

**** Tree Shaking

Concats two forms. Shakes the first form by removing any symbols not
present in second form.

In order to keep the generated C++ code compact only the functions used
will be present in the generated source file. Which means if you don't
use /println/ anywhere in the code it won't be defined in the final
C++ file, but if you use it, it and everything it uses will be
defined, in the case of /println/ it will pull /apply/, /print/ and
/newline/ with it.

#+name: core-compilation-shake-concat
#+begin_src clojure
  (defn shake-concat
    ([header form]
     (let [shakeable? (fn [f]
                        (or ((is-form? 'defn) f)
                            ((is-form? 'defnative) f)))
           header-symbols (->> (select-form header seq?)
                               flatten
                               (filter symbol?)
                               (into #{}))
           header-fns (->> (select-form header shakeable?)
                           (map #(vector (second %) %))
                           (into {}))
           header-non-shakeable (remove-form header shakeable?)
           form-expanded (expand-macros-all (concat header-non-shakeable form))
           fns (atom #{})
           _ (shake-concat form-expanded header-fns fns header-non-shakeable)
           header-shaked (remove-form header (fn [f]
                                               (and (shakeable? f)
                                                    (not (@fns (second f))))))]
       (concat header-shaked form)))
    ([form built-in fns non-shakeable]
     (morph-form form symbol?
                 #(do
                    (if-let [f (built-in %)]
                      (when (not (@fns %))
                        (swap! fns conj %)
                        (shake-concat (expand-macros-all (concat non-shakeable f))
                                      built-in fns non-shakeable))) %))))
#+end_src

**** Escape Analysis


     Determines that a certain allocation never escapes the local
     function. This means that allocation can be done on the stack.

#+name: core-compilation-escape-analysis-post
#+begin_src clojure
  (defn escape-analysis [form]
    (->> (escape-fn-calls form)
         (escape-fn-dispatch)
         (escape-lambdas)))
#+end_src

***** Escape Function Calls

#+name: core-compilation-escape-analysis
#+begin_src clojure
  (defn escape-fn-calls [form]
    (morph-form form
                (fn [f]
                  (and (seq? f)
                       (is-special-form? 'fir-lambda-object (first f))))
                (fn [f]
                  (let [[[_ & fn] & args] f]
                    `((~'fir-invoke-lambda-stack ~@fn) ~@args)))))
#+end_src

***** Escape Dispatch Functions

#+name: core-compilation-escape-analysis
#+begin_src clojure
  (defn escape-fn-dispatch [form]
    (morph-form form
                (fn [f]
                  (is-special-form? 'fir-dispatch-lambda f))
                (fn [f]
                  (morph-form f
                              (fn [f]
                                (is-special-form? 'fir-lambda-object f))
                              (fn [[_ & f]]
                                `(~'fir-invoke-lambda-stack ~@f))))))
#+end_src

***** Escape Lambda Classes

#+name: core-compilation-escape-analysis
#+begin_src clojure
  (defn escape-lambdas [form]
    (let [stack-lambda-pred (fn [f]
                              (and (seq? f)
                                   (is-special-form? 'fir-lambda-object (first f))))
          heap-lambdas (->> (select-form form (fn [f]
                                                (and (seq? f)
                                                     (is-special-form? 'fir-lambda-object f))))
                            (map second)
                            (into #{}))
          stack-lambdas (->> (select-form form (fn [f]
                                                 (and (seq? f)
                                                      (is-special-form? 'fir-invoke-lambda-stack f))))
                             (map second)
                             (into #{}))
          escapeable-lambdas (clojure.set/difference stack-lambdas heap-lambdas)]
      (morph-form form
                  (fn [f]
                    (and (seq? f)
                         (= (first f) 'fir-define-lambda)
                         (escapeable-lambdas (second f))))
                  (fn [[_ & f]]
                    `(~'fir-define-lambda-stack ~@f)))))
#+end_src

*** Helpers

During each pass we iterate over the nodes in the form using
/morph-form/ and /remove-form/, they both take a s-expression and a
predicate if the predicate returns true, morph-form will call /f/
passing the current node as an argument and replace that node with
/f/'s return value, remove-form on the other hand does what its name
suggests and removes the node when predicate returns true.

#+name: core-compilation-form-fns
#+begin_src clojure :tangle no
  (defn morph-form [tree pred f]
    (walk/prewalk (fn [x]
                    (if (pred x)
                      (f x)
                      x)) tree))

  (defn collect-form [tree pred f]
    (let [acc (atom [])]
      (doall (morph-form tree pred (fn [x] (swap! acc conj (f x)))))
      @acc))

  (defn remove-form [tree pred]
    (if (every? true? (map #(pred %) tree))
      (list )
      (loop [loc (zip/seq-zip tree)]
        (if (zip/end? loc)
          (zip/root loc)
          (recur
           (zip/next
            (if (pred (zip/node loc))
              (zip/remove loc)
              loc)))))))

  (defn select-form [tree pred]
    (loop [loc (zip/seq-zip tree)
           nodes []]
      (if (zip/end? loc)
        nodes
        (recur
         (zip/next loc)
         (if (pred (zip/node loc))
           (conj nodes (zip/node loc))
           nodes)))))

  (defn is-form? [& s]
    (fn [f]
      (and (seq? f)
           (some true? (map #(= % (first f)) s)))))
#+end_src

#+name: core-code-generation-misc
#+begin_src clojure :tangle no

  (defn read-clojure-file [f]
    (try
      (read-string (str \( (FileUtils/readFileToString (file f)) \)))
      (catch Exception e
        (warn "error reading =>" f)
        (System/exit 1))))

  (defn read-clojure-file-from-url [f]
    (try
      (read-string (str \( (read-from-url f) \)))
      (catch Exception e
        (warn "error reading =>" f)
        (System/exit 1))))

  (defn is-special-form? [s f]
    (and (seq? f)
         (= (first f) s)))
#+end_src

** Code Generation

The compiler's code generation phase takes a single pass over the
transformed Clojure code and outputs C++ code. (a single .cpp file)
This is done by running /emit/ on the final intermediate
representation.

#+name: core-code-generation-emit
#+begin_src clojure :tangle no  
  (defmulti emit (fn [form _]
                   (cond (is-special-form? 'fir_define_lambda form) 'fir_define_lambda
                         (is-special-form? 'fir_define_lambda_stack form) 'fir_define_lambda_stack
                         (is-special-form? 'fir_dispatch_lambda form) 'fir_dispatch_lambda
                         (is-special-form? 'fir_lambda_object form) 'fir_lambda_object
                         (is-special-form? 'fir_invoke_lambda_stack form) 'fir_invoke_lambda_stack
                         (is-special-form? 'fir_define_var form) 'fir_define_var
                         (is-special-form? 'defobject form) 'defobject
                         (is-special-form? 'native_header form) 'native_header
                         (is-special-form? 'native_declare form) 'native_declare
                         (is-special-form? 'native_define form) 'native_define
                         (is-special-form? 'if form) 'if
                         (is-special-form? 'def form) 'def
                         (symbol? form) :symbol
                         (keyword? form) :keyword
                         (number? form) :number
                         (nil? form) :nil
                         (char? form) :char
                         (string? form) :string
                         (or (true? form) (false? form)) :boolean
                         (seq? form) :invoke-lambda)))

  (defn emit-ast
    [ast state]
    (reduce (fn[h v]
              (conj h (emit v state)))
            [] ast))
#+end_src

Without preprocessing following forms,

#+begin_src clojure :tangle no
  (emit '(list 1 2 3) (ref {}))
  
  (emit '(+ 1 2) (ref {}))
  
  (emit '(if (< a b)
           b a)
        (ref {}))
#+end_src

would evaluate to,

#+begin_example
  "run(list,obj<number>(1),obj<number>(2),obj<number>(3))"
  "run(+,obj<number>(1),obj<number>(2))"
  "((<,b,a) ? a : b)"
#+end_example

So the actual compilation will just map emit to all forms passed and
/string-template/ will handle the job of putting them into an empty
C++ skeleton.

#+name: core-code-generation-misc
#+begin_src clojure :tangle no
  (defn append-to! [r ks v]
    (let [cv (reduce (fn[h v] (v h)) @r ks)]
      (swap! r assoc-in ks (conj cv v))))
#+end_src

#+name: core-code-generation-emit-source
#+begin_src clojure :tangle no
  (defn emit-source [form options]
    (let [state (atom {:native-headers []
                       :native-declarations []
                       :objects []
                       :symbol-table #{}
                       :lambdas []
                       :native-defines []})
          ast (compile form options)
          body (emit-ast ast state)]
      (when (:ast options)
        (pprint/pprint ast))
      (assoc @state :body body)))
#+end_src

*** Code Emitting

Generated C++ code has the following structure, (All Ferret code is
defined within *ferret* namespace. All Ferret macros starts with
*FERRET_*.)

 - Detect Hardware
 - Include files
 - Ferret Header (src/ferret/runtime.h)
 - Ferret Native Runtime Prototypes (runtime::first, runtime::rest
   etc.)
 - Native Declarations
 - Object Definitions
 - Symbol Definitions
 - Native Runtime Implementations
 - Lambda Prototypes
 - Lambda Implementations
 - Ferret Main
 - Hardware Dependent Main Functions

**** Object Types

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit :symbol [form state] (str form))

  (defmethod emit :string [form state]
    (str "obj<string>(\"" (org.apache.commons.lang.StringEscapeUtils/escapeJava form) "\"," (count form) ")"))

  (defmethod emit :boolean [form state] (str "obj<boolean>(" form ")"))

  (defmethod emit :nil [form state] "nil()")

  (defmethod emit :keyword [form state]
    (str "obj<keyword>(" (reduce (fn[h v] (+ h (int v))) 0 (str form)) ")"))

  (defmethod emit :char [form state] (str "obj<number>((number_t)" (int form) ")"))

  (defmethod emit :number [form state] (str "obj<number>((real_t)" (double form) ")"))
#+end_src

**** Special Forms

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'def [[_ name & form] state]
    (append-to! state [:symbol-table] name)
    (str "(" name " = " (apply str (emit-ast form state)) ")"))

  (defmethod emit 'if [[_ cond t f] state]
    (let [cond (emit cond state)
          t (emit t state)
          f (if (nil? f) "nil()" (emit f state))]
      (apply str "(" cond " ? " t " : " f ")")))

  (defmethod emit :invoke-lambda [[fn & args] state]
    (invoke-lambda (emit fn state) (emit-ast args state)))

  (defmethod emit 'defobject [[_ name & spec] state]
    (append-to! state [:objects] (define-object name spec)) "")

  (defmethod emit 'fir_define_var [[_ name form] state]
    (str "var " name " = " (emit form state)))

  (defmethod emit 'native_header [[_ & declarations] state]
    (append-to! state [:native-headers] declarations) "")

  (defmethod emit 'native_declare [[_ declaration] state]
    (append-to! state [:native-declarations] declaration) "")

  (defmethod emit 'native_define [[_ define] state]
    (append-to! state [:native-defines] define) "")
#+end_src

**** Lambdas

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'fir_lambda_object [f state]
    (lambda-object-heap f))

  (defmethod emit 'fir_invoke_lambda_stack [f state]
    (lambda-object-stack f))

  (defn emit-define-lambda-aux [name env args body state]
    (let [native-declarations (filter #((is-form? 'native_declare) %) body)
          body (filter #(not ((is-form? 'native_declare) %)) body)
          body (cond  (empty? body)
                      ["nil();"]
                      (and (= 1 (count body))
                           (seq? (first body))
                           (= 'fir_dispatch_lambda (first (first body))))
                      [(emit (first body) state) "nil();"]
                      (and (= 1 (count body))
                           (string? (first body)))
                      (let [inline (first body) 
                            body (if (= (last inline) \;)
                                   inline
                                   (str inline \;))]
                        (if (neg? (.indexOf body "__result"))
                          [body "nil();"]
                          ["var __result;" body "__result;"]))
                      :default (reduce (fn[h v]
                                         (conj h (str v \;)))
                                       [] (emit-ast body state)))
          env (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %)))))]
      (doseq [dec native-declarations] 
        (emit dec state))
      [name env (lambda-arguments args) body]))

  (defmethod emit 'fir_define_lambda [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body}) ""))

  (defmethod emit 'fir_define_lambda_stack [[_ name env args & body] state]
    (let [[name env args body] (emit-define-lambda-aux name env args body state)]
      (append-to! state [:lambdas]
                  {:name name :env env :args args :body body :stack true}) ""))
#+end_src

#+name: core-code-generation-emit-source-methods
#+begin_src clojure :tangle no
  (defmethod emit 'fir_dispatch_lambda [[_ args-symbol & fns] state]
    (let [fns (->> fns
                   (partition 2))
          nil-dispatch (filter #(= (first %) 0) fns)]
      (str
       (if (not (empty? nil-dispatch))
         (str "if (" args-symbol ".is_nil())
                return " (lambda-object-stack
                          (->> nil-dispatch first second)) ".invoke(nil());")
         "")
       "switch(runtime::count(" args-symbol ")) {"
       (->> fns
            (map (fn [[count fn]]
                   (if (= count 'true)
                     (str "default: "
                          " return " (lambda-object-stack fn) ".invoke(" args-symbol ");")
                     (str "case " count " : "
                          " return " (lambda-object-stack fn) ".invoke(" args-symbol ");"))))
            (apply str)) "}")))
#+end_src

*** Code Templates
  :PROPERTIES:
  :noweb-ref: code-templates
  :END:
**** Objects

#+begin_src clojure :tangle no
  (defn define-object-depricated [name body]
    (let [specs (into {} (map #(vector (first %) (rest %)) body))
          interface (if (nil? (specs 'interface))
                      "object_t"
                      (apply str (rest (str (first (specs 'interface))))))
          interface-only (cond (specs 'interface) false
                               (empty? (specs 'new)) true
                               :defaul false)
          fns (specs 'fns)
          raw-fns (filter #(= 1 (count %)) fns)
          fns (filter #(= 3 (count %)) fns)]
      (-> (create-view "
       $if(object_type)$
         namespace runtime {
          namespace type {
           const size_t $type$ = $type_val$;}}
       $endif$

       $if(template)$
         template<$template:{$it$} ;separator=\",\"$>
       $endif$
       class $name$ : public $interface$ {
         $data:{$it$} ;separator=\"\n\"$
       public:
         $interfaces:{virtual $it$ = 0;} ;separator=\"\n\"$

         $new:{it | $name$($first(it)$){
           $first(rest(it))$
         }} ;separator=\"\n\"$

         $if(object_type)$
          size_t type() const { return runtime::type::$type$; }
         $endif$

         $if(equals)$
          var equals(var o){
           $equals$
          }
         $endif$

         $if(stream_console)$
         #if !defined(FERRET_DISABLE_STD_OUT)
          var stream_console() const {
           $stream_console$
          }
         #endif
         $endif$

         $raw_fns:{it | $it$ } ;separator=\"\n\"$

         $fns:{it | $first(it)$($first(rest(it))$){
           $first(rest(rest(it)))$
         }} ;separator=\"\n\"$

         $ifdef_fns:{it | #$first(it)$
           $first(rest(it))$($first(rest(rest(it)))$){
           $first(rest(rest(rest(it))))$
         }
       #endif} ;separator=\"\n\"$
       };
       $post_code$")
          (fill-view! "name"           name)
          (fill-view! "template"       (specs 'template))
          (fill-view! "interface"      interface)
          (fill-view! "interface_only" interface-only)
          (fill-view! "object_type"    (cond (specs 'force_type) true
                                             interface-only false
                                             :default true))
          (fill-view! "type"           (str name))
          (fill-view! "type_val"       (gensym ""))
          (fill-view! "data"           (specs 'data))
          (fill-view! "new"            (specs 'new))
          (fill-view! "equals"         (first (specs 'equals)))
          (fill-view! "stream_console" (first (specs 'stream_console)))
          (fill-view! "interfaces"     (specs 'interfaces))
          (fill-view! "fns"            fns)
          (fill-view! "raw_fns"        raw-fns)
          (fill-view! "ifdef_fns"      (filter #(= 4 (count %)) (specs 'fns)))
          (fill-view! "post_code"      (first (specs 'post_code)))
          (render-view))))

  (defn define-object [name f]
    (if (not (string? (first f)))
      (define-object-depricated name f)
      (-> (create-view "namespace runtime {
                         namespace type {
                          const size_t $type$ = $type_val$;
                         }
                        }

                        $body$")
          (fill-view! "type"     (str name))
          (fill-view! "type_val" (gensym ""))
          (fill-view! "body"     (read-from-url (first f)))
          (render-view))))
#+end_src    

**** Lambdas

#+begin_src clojure :tangle no
  (let [env (fn [[_ _ & env]]
              (->> env
                   (flatten)
                   (filter #(and (not (= '& %))
                                 (not (= '_ %))))))]
    (defn lambda-object-heap [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str "obj<" n ">()")
          (str "obj<" n ">(" (apply str (interpose \, e)) ")"))))

    (defn lambda-object-stack [l]
      (let [n (second l)
            e (env l)]
        (if (empty? e)
          (str n "()")
          (str n "(" (apply str (interpose \, e)) ")")))))

  (defn invoke-lambda [n args]
    (if (empty? args)
      (str "run(" n ")")
      (str "run(" n ","  (apply str (interpose \, args))")")))
#+end_src    

Initialize function arguments. Clojure style list structuring is supported.

#+begin_src clojure :tangle no
  (let [set-var (fn [val arg accesor]
                  (str "var " val " = "
                       (reduce (fn[h v] (str v "(" h ")")) arg accesor)))
        nth (fn [pos]
              (flatten [(repeat pos "runtime::rest") "runtime::first"]))]
    
    (defn lambda-arguments
      ([args]
       (flatten (lambda-arguments args "_args_")))
      ([args name]
       (let [[args va-args] (if (some #{'&} args)
                              (split-at (.indexOf args '&) args)
                              [args []])]
         [(->> (map-indexed (fn [pos val] (vector pos val)) args)
               (filter #(not= (second %) '_))
               (reduce
                (fn [h [pos val]]
                  (let [accesor (nth pos)]
                    (conj h
                          (if (coll? val)
                            (lambda-arguments
                             val (reduce (fn[h v] (str v "(" h ")")) name accesor))
                            (set-var val name accesor))))) []))
          (if (empty? va-args)
            []
            (set-var (last va-args) name (repeat (count args) "runtime::rest")))]))))
#+end_src

#+begin_src clojure :tangle no
  (defn lambda-definitions [lambdas]
    (-> (create-view
         "$lambdas: {lambda|
           $if(!lambda.stack)$
            class $lambda.name$ final : public lambda_i{
           $else$
            class $lambda.name$  \\{
           $endif$
             $lambda.env:{var $it$;} ;separator=\"\n\"$
           public:
             $if(lambda.env)$
               explicit $lambda.name$ ($lambda.env:{var $it$} ;separator=\",\"$) :
                 $lambda.env:{$it$($it$)} ;separator=\",\"$ { }
             $endif$
             $if(lambda.args)$
                 var invoke (var _args_) const $if(!lambda.stack)$ final $endif$ ;
             $else$
                 var invoke (var) const $if(!lambda.stack)$ final $endif$ ;
             $endif$
           };};separator=\"\n\n\"$")
        (fill-view! "lambdas" lambdas)
        (render-view)))

  (defn lambda-implementations [lambdas]
    (-> (create-view
         "$lambdas: {lambda|
           $if(lambda.args)$
               inline var $lambda.name$::invoke (var _args_) const
           $else$
               inline var $lambda.name$::invoke (var) const
           $endif$
               {
                 $lambda.args:{args | $args$; } ;separator=\"\n\"$
     
                 $trunc(lambda.body):{$it$} ;separator=\"\n\"$
                 return $last(lambda.body):{$it$} ;separator=\"\n\"$
               }
           };separator=\"\n\n\"$")
        (fill-view! "lambdas" lambdas)
        (render-view)))
#+end_src    

**** Program

#+begin_src clojure :tangle no :noweb yes
  (defn solution-template [source]
    (let [{:keys [body lambdas symbol-table native-headers objects
                  native-declarations native-defines]} source
          native-headers (->> native-headers flatten (into #{}))]
      (-> (create-view "
          $native_defines:{$it$} ;separator=\"\n\"$

          $ferret_header$

          $native_headers:{#include \"$it$\"} ;separator=\"\n\"$

          // Runtime Prototypes
          namespace ferret{
           <<runtime-native-prototypes>>
          }

          // Objects
          namespace ferret{
           $objects:{$it$} ;separator=\"\n\"$
          }

          // Symbols
          namespace ferret{
           $symbols:{var $it$;} ;separator=\"\n\"$
          }

          $native_declarations:{$it$} ;separator=\"\n\"$

          // Runtime Implementations
          namespace ferret{
           <<runtime-native-math-misc>>
           <<runtime-native-implementations>>
          }

          // Lambda Prototypes
          namespace ferret{
            $lambda_classes:{$it$} ;separator=\"\n\"$
          }

          // Command Line Arguments
          #if defined(FERRET_STD_LIB) &&                    \\
              !defined(FERRET_DISABLE_CLI_ARGS) &&   \\
              !defined(FERRET_DISABLE_STD_MAIN)
            ferret::var _star_command_line_args_star_;
          #endif

          // Lambda Implementations
          namespace ferret{
            $lambda_bodies:{$it$} ;separator=\"\n\"$
          }

          // Program Run
          namespace ferret{
           namespace program{
            void run(){
             $body:{$it$;} ;separator=\"\n\"$ 
            }
           }
          }

         <<runtime-native-program-run-std-main>>
         <<runtime-native-program-arduino>>\n")
          (fill-view! "ferret_header"       (read-from-url "ferret/runtime.h"))
          (fill-view! "native_headers"      native-headers)
          (fill-view! "body"                (filter #(not (empty? %)) body))
          (fill-view! "lambda_classes"      (lambda-definitions lambdas))
          (fill-view! "lambda_bodies"       (lambda-implementations lambdas))
          (fill-view! "symbols"             symbol-table)
          (fill-view! "native_declarations" native-declarations)
          (fill-view! "objects"             objects)
          (fill-view! "native_defines"      native-defines)
          (render-view))))
#+end_src

** Main
*** Options

   Default compile options, 

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options [& [options]]
      (merge {:compiler "g++"
              :compiler-options ["-std=c++11"]
              :source-extension "cpp"
              :base-name "solution"}
             options))

    (defn cpp-file-name [options]
      (str (:output-path options) (:base-name options) "." (:source-extension options)))
  #+end_src

   Read the /cpp/ file parse build options embedded in it.

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile-options-parse-source [file]
      (try
        (let [program (slurp file)
              options (->> program
                           (re-seq #"(?s)build-conf-begin.*?//(.*?)// build-conf-end")
                           (map second)
                           (map #(.replaceAll % "//" ""))
                           (map #(.replaceAll % "\n" " "))
                           (map read-string))
              keys (->> options
                        (map #(keys %))
                        flatten
                        (into #{})
                        (into []))
              combine (fn [key]
                        (->> options
                             (reduce (fn[h v]
                                       (if (nil? (key v))
                                         h
                                         (apply merge (flatten [h (key v)])))) #{})
                             (into [])))]
          (compile-options
           (reduce (fn[h v]
                     (assoc h v (combine v))) {} keys)))
        (catch Exception e
          (compile-options {}))))
  #+end_src

   Takes the compiler CLI arguments and a file name, returns a map of
   build options.

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn build-specs [input args]
      (fn []
        (let [base-name (org.apache.commons.io.FilenameUtils/getBaseName input)
              path (str (org.apache.commons.io.FilenameUtils/getPrefix input)
                        (org.apache.commons.io.FilenameUtils/getPath input))
              path (if (empty? path)
                     "./"
                     path)
              default-compiled-file (file (str path base-name ".cpp"))
              default-options (compile-options-parse-source default-compiled-file)]
          (-> default-options
              (assoc :input-file input)
              (assoc :base-name base-name)
              (assoc :path path)
              (assoc :output-path path)
              (assoc :ast (->> args :options :ast))
              (assoc :compile-program (->> args :options :compile))
              (assoc :release (->> args :options :release))
              (assoc :format-code (not (->> args :options :disable-formatting)))
              (assoc :global-functions (->> args :options :global-functions))
              (assoc :extra-source-files
                     (cond (not (empty? (:arguments args)))
                           (:arguments args)
                           (not (empty? (:extra-source-files default-options)))
                           (:extra-source-files default-options)
                           :default []))))))
  #+end_src

*** Compile to C++

   Compile the form to C++,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn compile->cpp [form options]
      (let [file-name (cpp-file-name options)
            source (emit-source form options)
            solution (solution-template source)]
        (FileUtils/writeStringToFile (file file-name) (.trim solution))
        (info "compiled" "=>" file-name)
        true))
  #+end_src

*** Compile to Binary

   Compile C++ code to binary,

  #+name: core-code-compile-code
  #+begin_src clojure
    (defn cxx-command [options]
      (if (:command options)
        (flatten ["/usr/bin/env" "sh" "-c" (:command options)])
        (let [cxx (if (System/getenv "CXX")
                    (System/getenv "CXX")
                    (:compiler options))
              cxx-options (concat (map #(str %) (:compiler-options options))
                                  (if (System/getenv "CXXFLAGS")
                                    (seq (.split (System/getenv "CXXFLAGS") " "))))
              source-files (map #(let [extension (org.apache.commons.io.FilenameUtils/getExtension %)]
                                   [(cond (= extension "c") ["-x" "c"]
                                          (= extension "c++") ["-x" "c++"]
                                          :default "")
                                    %])
                                (:extra-source-files options))]
          (flatten [cxx cxx-options source-files
                    ["-x" "c++"] (str (:base-name options) "." (:source-extension options))]))))

    (defn compile->binary [options]
      (let [command (cxx-command options)]
        (info "building" "=>" (apply str (interpose " " command)))
        (let [build-dir (:output-path options)
              ret (try
                    (with-sh-dir build-dir
                      (apply sh command))
                    (catch Exception e
                      (warn (str "error executing C++ compiler."))
                      (warn (str "" (.getMessage e)))
                      (System/exit 1)))]
          (if (not= 0 (:exit ret))
            (do (warn "build error")
                (warn (:err ret))
                (System/exit 1)))
          true)))
  #+end_src

*** Build Solution

    Compile and build program,

   #+name: core-code-compile-code
   #+begin_src clojure
     (defn clang-format [options]
       (let [file (cpp-file-name options)
             source (try (with-sh-dir "./"
                           (sh "clang-format" "-style" "{Standard: Cpp11}" file))
                         (catch Exception e nil))]
         (if source
           (do (info "formatting code") 
               (spit file (:out source)))
           (trace "install clang-format for formatted output (optional)"))))

     (defn build-solution [spec-fn]
       (let [{:keys [input-file compile-program format-code path]} (spec-fn)]
         (info "dir =>" path)
         (info "file =>" input-file)
         
         (compile->cpp (read-clojure-file input-file) (spec-fn))
         
         (when format-code
           (clang-format (spec-fn)))
         
         (when compile-program
           (compile->binary (spec-fn)))))
   #+end_src

*** Compiler Main

    Compiler options,

   #+name: core-code-compile-code
   #+begin_src clojure
     (def program-options [["-i" "--input FILE" "Input File" :default "./core.clj"]
                           ["-c" "--compile" "Compile Solution"]
                           ["-w" "--watch-input" "Automatically recompile input file on change."]
                           [nil "--release" "Compile in Release Mode. Strip Debug Information."]
                           [nil "--disable-formatting" "Disables Solution Formatting Using clang-format."]
                           [nil "--global-functions" "Disables replace-fn-call-sites Optimization."]
                           [nil "--ast" "Print Intermediate AST."]
                           ["-h" "--help" "Print Help"]])
   #+end_src

   Compiler /main/,

   #+name: core-code-compile-code
   #+begin_src clojure
     (defn -main [& args]
       (let [args (parse-opts args program-options)
             {:keys [help input watch-input]} (:options args)]

         (when help
           (try
             (let [version (read-from-url "build.info")]
               (print "ferret-lisp build:" version))
             (catch Exception e
               (print "ferret-lisp")))
           (println )
           (println )
           (println (:summary args))
           (System/exit 0))

         (when (not (.exists (file input)))
           (warn "no input file")
           (System/exit 1))

         (let [specs (build-specs input args)]
           (if (not watch-input)
             (build-solution specs)
             (do (watcher/watcher [input]
                                  (watcher/rate 1000)
                                  (watcher/on-change
                                   (fn [_] (build-solution specs))))
                 @(promise)))
           (shutdown-agents))))
   #+end_src

*** Logging

  #+name: core-logging
  #+begin_src clojure
    (def log-formatter (proxy [java.util.logging.Formatter] []
                         (format
                           [^java.util.logging.LogRecord record]
                           (let [level (-> record .getLevel .toString clojure.string/lower-case)
                                 level (if (or (= :unix (os-name))
                                               (= :mac (os-name))
                                               (= :solaris (os-name)))
                                         (if (= level "warning")
                                           (color/red level)
                                           (color/green level))
                                         level)
                                 now (.getTime (java.util.Calendar/getInstance))
                                 frmtr (java.text.SimpleDateFormat. "HH:mm:ss")]
                             (str (.format frmtr now) " " level " " (.getMessage record) "\n")))))

    (def log-handler (proxy [java.util.logging.Handler] []
                       (publish [^java.util.logging.LogRecord record]
                         (when (and (.isLoggable ^java.util.logging.Handler this record)
                                    (instance? java.io.PrintWriter *out*))
                           (.print ^java.io.PrintWriter *out* 
                                   (.format ^java.util.logging.Formatter log-formatter record))))
                       (flush [] (.flush ^java.io.PrintWriter *out*))
                       (close [] 
                         ;;(.close *out*)
                         )))

    (.addHandler (java.util.logging.Logger/getLogger "") log-handler)

    (let [^java.util.logging.LogManager$RootLogger logger (java.util.logging.Logger/getLogger "")]
      (doseq [^java.util.logging.Handler handler (.getHandlers logger)]
        (. handler setFormatter log-formatter)))

    (defn set-log-level! [& [level]]
      (let [^java.util.logging.LogManager$RootLogger logger
            (java.util.logging.Logger/getLogger "")
            level (cond (nil? level) java.util.logging.Level/ALL
                        (= level :trace) java.util.logging.Level/FINEST
                        (= level :debug) java.util.logging.Level/FINE
                        (= level :info) java.util.logging.Level/INFO
                        (= level :warn) java.util.logging.Level/WARNING)]
        
        (.setLevel logger level)
        (doseq [^java.util.logging.Handler handler (.getHandlers logger)]
          (. handler setLevel level))))

    (set-log-level! :info)
  #+end_src

* Native Core

Runtime needed on the C++ side to support [[Clojure Core]]. [[Object System][Object system]],
[[Reference Counting][garbage collection]],[[Memory Pool][memory pooling]] and host specific initialization
code. (ie. printing on different embedded systems.)

** Object System

All Ferret objects derive from a [[Base]] class.

Built in objects,

 - [[Pointer]]
 - [[Number]]
 - [[Keyword]] 
 - [[Sequence]]
 - [[Lazy Sequence]]
 - [[String]] - As [[Sequence]] of [[Number]]s
 - [[Boolean]]
 - [[Atom]] - Mimics Clojure atoms.

Built in interfaces,

 - [[Lambda]] - Provides *invoke* for callable objects.
 - [[Seekable]] - Provides *first*, *rest*, *cons* for [[Seekable]]
   containers.

*** Base

All our types are derived from the base Object type. Which is a
=typedef= of =obj::base<FERRET_RC_POLICY,FERRET_ALLOC_POLICY>=. See
[[Reference Counting]] for available reference counting policies and
[[Memory Allocation]] for available allocation policies.

#+name: runtime-native-object
#+begin_src c++ :tangle no
  namespace object{
    template <typename rc, typename mem>
    class base : public rc, public mem{
    public:
      base() : rc(0) { }
      base(const base& other): rc(other) { }
      virtual ~base() { };
    
      virtual size_t type() const = 0;
    
  #if !defined(FERRET_DISABLE_STD_OUT)
      virtual var stream_console() const = 0;
  #endif
    
      virtual var equals(var o) = 0;
    };

    #if defined(FERRET_DISABLE_MULTI_THREADING)
      #define FERRET_RC_POLICY mem::gc::rc
    #elif defined(FERRET_DISABLE_RC)
      #define FERRET_RC_POLICY mem::gc::no_rc
    #else
      #define FERRET_RC_POLICY mem::gc::atomic_rc
    #endif

    #if defined(FERRET_MEMORY_POOL_SIZE)
      #define FERRET_ALLOC_POLICY mem::allocator::pool
    #else
      #define FERRET_ALLOC_POLICY mem::allocator::system
    #endif
  }

  typedef object::base<FERRET_RC_POLICY,FERRET_ALLOC_POLICY> object_t;
#+end_src

*** Objects
**** Pointer

A /pointer/ object keeps a reference to a C++ pointer.

#+begin_src c++
  var num = obj<pointer>(new int(42));
  int *ptr = pointer::to_pointer<int>(ptr);
#+end_src

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject pointer "ferret/obj/pointer_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/pointer_o.h
  class pointer : public object_t {
    void* _payload;
  public:


    size_t type() const { return runtime::type::pointer; }

    var equals(var o){
      return obj<boolean>(_payload == o.cast<pointer>()->payload());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("pointer<");
      runtime::print(_payload);
      runtime::print(">");return nil();
    }
  #endif

    explicit pointer(void* p) : _payload(p) {} 

    void* payload() const {
      return _payload;
    }
    template<typename T> static T* to_pointer(var v){
      return ((T *) v.cast<pointer>()->payload());
    }
    template<typename T> static T& to_reference(var v){
      return (*(pointer::to_pointer<T>(v)));
    }
  };
#+end_src

A =heavy_pointer= object contains a pointer and a function to be called
right before garbage collection. This is similar to /finalizer/ in
Java.

#+begin_src clojure
  (let [val (cxx "__result = obj<pointer>(new int(0));")
        gc (fn []
             (cxx "delete pointer::to_pointer<int>(val);")
             (println "Cleanup..."))]
    (new-heavy-pointer val gc))

  ;; => Cleanup...
#+end_src

#+name: runtime-clojure-heavy-pointer-object
#+begin_src clojure :tangle no
  (defobject heavy_pointer "ferret/obj/heavy_pointer_o.h")

  (defn new-heavy-pointer [ptr gc]
    "__result = obj<heavy_pointer>(ptr,gc)")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/heavy_pointer_o.h
  class heavy_pointer : public object_t {
    var _payload;
    var gc_fn;
  public:

    size_t type() const { return runtime::type::heavy_pointer; }

    var equals(var o){
      return _payload.equals(o.cast<heavy_pointer>()->payload());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      return _payload.cast<pointer>()->stream_console();
    }
  #endif

    explicit heavy_pointer(var p, var gc) : _payload(p), gc_fn(gc) {} 

    ~heavy_pointer(){
      gc_fn.cast<lambda_i>()->invoke(runtime::list(_payload));
    }
    var payload() const {
      return _payload;
    }
  };
#+end_src

A /value/ object keeps a native object. Useful when working with
modern C++ libraries that use smart pointers for memory management.

#+name: value-test-helpers
#+begin_src clojure :tangle no
  (native-declare "class data{ 
                   public: 
                    int x; 
                    
                    explicit data(int _x) : x(_x) {} 
                    int content() { return x; }
                   };")

  (defn make-data [x]
    "__result = obj<value<data>>(number::to<int>(x))")

  (defn get-data [x]
    "__result = obj<number>((number_t) value<data>::to_value(x).content());")
#+end_src

#+name: runtime-clojure-pointer-object
#+begin_src clojure :tangle no
  (defobject value "ferret/obj/value_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/value_o.h
  template <typename T>
  class value : public object_t {
    T _payload;
  public:

    size_t type() const { return runtime::type::value; }

    var equals(var o){
      return obj<boolean>(this == o.get());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("value<");
      runtime::print((void*)&_payload);
      runtime::print(">");
      return nil();
    }
  #endif

    template <typename... Args>
    explicit value(Args&&... args) : _payload(static_cast<Args&&>(args)...) { } 

    T payload() const {
      return _payload;
    }
    static T to_value(var v){
      return v.cast<value<T>>()->payload();
    }
  };
#+end_src

**** Number

In the interest of simplicity Ferret supports only one type of number:
floating point numbers. By default these are double precision floating
point numbers. However Ferret programs can easily be recompiled to
support any real number type the system supported.

Default number configuration,

#+name: runtime-native-number-config-macros
#+begin_src c++ :tangle no
  namespace ferret{
  #if !defined(FERRET_NUMBER_TYPE)
     #define FERRET_NUMBER_TYPE int
  #endif

  #if !defined(FERRET_REAL_TYPE)
     #define FERRET_REAL_TYPE   double
  #endif

  #if !defined(FERRET_REAL_EPSILON)
     #define FERRET_REAL_EPSILON   0.00001
  #endif
    
    typedef FERRET_NUMBER_TYPE           number_t;                   // Whole number Container.
    typedef FERRET_REAL_TYPE             real_t;                     // Real number Container.
  #if !defined(FERRET_DISABLE_STD_OUT)
    const   size_t                       number_precision = 4;       // number Format String (fprinf)
  #endif

  #ifndef M_PI
    #define M_PI 3.14159265358979323846
  #endif
  }
#+end_src

Helper functions,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  namespace runtime{
    #undef min
    #undef abs

    template<typename T>
    T min(T a, T b);

    template<typename T>
    T abs(T a);
  }
#+end_src

#+name: runtime-native-math-misc
#+begin_src c++ :tangle no
  namespace runtime{
    template<typename T>
    T min(T a, T b){
      return ((a)<(b)?(a):(b));
    }

    template<typename T>
    T abs(T a){
      return ((a)<0 ? -(a) : (a));
    }
  }
#+end_src

number Object,

#+name: runtime-clojure-number-object
#+begin_src clojure :tangle no
  (defobject number "ferret/obj/number_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/number_o.h
  class number : public object_t {
    real_t _word;
  public:


    size_t type() const { return runtime::type::number; }

    var equals(var o){
      if (runtime::abs(_word - o.cast<number>()->word()) < FERRET_REAL_EPSILON)
        return obj<boolean>(true);
      else
        return obj<boolean>(false);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print(_word); return nil();
    }
  #endif

    template<typename T> explicit number(T x) : _word((real_t)x) {} 

    real_t word() const {
      return _word;
    }
    
    template<typename T> T as() const {
      T::unimplemented_function;
    }
    
    var add(var v) const {
      return obj<number>(_word + v.cast<number>()->word());
    }
    var sub(var v) const {
      return obj<number>(_word - v.cast<number>()->word());
    }
    var mul(var v) const {
      return obj<number>(_word * v.cast<number>()->word());
    }
    var div(var v) const {
      return obj<number>(_word / v.cast<number>()->word());
    }
    var is_smaller(var v) const {
      return obj<boolean>(_word < v.cast<number>()->word());
    }
    var is_smaller_equal(var v) const {
      return obj<boolean>(_word <= v.cast<number>()->word());
    }
    var is_bigger(var v) const {
      return obj<boolean>(_word > v.cast<number>()->word());
    }
    var is_bigger_equal(var v) const {
      return obj<boolean>(_word >= v.cast<number>()->word());
    }
    
    template<typename T> static T to(var v){
      return (T)v.cast<number>()->word();
    }
  };

#+end_src

**** Keyword

Each keyword in the program is converted to an /keyword/ object. A
/keyword/ holds a simple hash of the keyword as an integer.

#+name: runtime-clojure-keyword-object
#+begin_src clojure :tangle no
  (defobject keyword "ferret/obj/keyword_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/keyword_o.h
  class keyword : public object_t {
    number_t _word;
    
  public:


    size_t type() const { return runtime::type::keyword; }

    var equals(var o){
      return obj<boolean>(_word == o.cast<keyword>()->word());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print(_word); return nil();
    }
  #endif

    explicit keyword(number_t w) : _word(w) {} 
    explicit keyword(const char * str){
      _word = 0;
      for (number_t i = 0; str[i] != '\0'; i++){
        _word = _word + (number_t)str[i];
      }
    } 

    number_t word() const {
      return _word;
    }
  };
#+end_src

**** Sequence

Linked list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject empty_sequence "ferret/obj/empty_sequence_o.h")
  (defobject sequence "ferret/obj/sequence_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/empty_sequence_o.h
  class empty_sequence : public seekable_i {
  public:

    size_t type() const { return runtime::type::empty_sequence; }

    var equals(var){
      return obj<boolean>(true);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("()");
      return nil();
    }
  #endif

    var cons(var v){
      return runtime::list(v);
    }
    var first() const {
      return nil();
    }
    var rest() const {
      return nil();
    }
  };
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/sequence_o.h
  class sequence : public seekable_i {
    var data;
    var next;
  public:

    size_t type() const { return runtime::type::sequence; }

    var equals(var o){
      if(data != runtime::first(o))
        return obj<boolean>(false);
      
      var other = runtime::rest(o);
      for(auto it : runtime::range(rest())){
        if (other.is_nil() || it != runtime::first(other))
          return obj<boolean>(false);
        other = runtime::rest(other);
      }

      if (other.is_nil())
        return obj<boolean>(true);
      else
        return obj<boolean>(false);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("(");
      data.stream_console();
      for(auto i : runtime::range(next)){
        runtime::print(" ");
        i.stream_console();
      }
      runtime::print(")");
      return nil();
    }
  #endif

    explicit sequence(var d = var(), var n = var()) : data(d), next(n) {} 

    var cons(var x){
      return obj<sequence>(x, var(this));
    }
    var first() const {
      return data;
    }
    var rest() const {
      return next;
    }
    template <typename T>
    static T to(var){
      T::unimplemented_function;
    }
    template <typename T>
    static var from(T){
      T::unimplemented_function; return nil();
    }

  };
  namespace runtime {
    inline var list() { 
      return obj<empty_sequence>();
    }
    inline var list(var v) { 
      return obj<sequence>(v,nil());
    }
                      
    template <typename... Args>
    inline var list(var first, Args... args) { 
      return obj<sequence>(first, list(args...));
    }
  }

  #ifdef FERRET_STD_LIB
  typedef ::std::vector<var>  std_vector;

  template <> std_vector sequence::to(var v) { 
    std_vector ret;
    for(auto it : runtime::range(v))
      ret.push_back(it);
    return ret;
  }

  template <> var sequence::from(std_vector v) { 
    var ret;
    for(auto it : v)
      ret = runtime::cons(it,ret);
    return ret;
  }
  #endif
#+end_src

**** Lazy Sequence

A lazy list container implementing the seekable interface.

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defobject lazy_sequence "ferret/obj/lazy_sequence_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/lazy_sequence_o.h
  class lazy_sequence : public seekable_i {
    var head;
    var thunk;
  public:

    size_t type() const { return runtime::type::lazy_sequence; }

    var sval() const {
      if (head.is_nil())
        return runtime::first(run(thunk));
      
      return head;
    }

    var equals(var o){
      if(sval() != runtime::first(o))
        return obj<boolean>(false);
      
      var other = runtime::rest(o);
      for(auto it : runtime::range(rest())){
        if (other.is_nil() || it != runtime::first(other))
          return obj<boolean>(false);
        other = runtime::rest(other);
      }

      if (other.is_nil())
        return obj<boolean>(true);
      else
        return obj<boolean>(false);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("(");
      sval().stream_console();
      for(auto i : runtime::range(rest())){
        runtime::print(" ");
        i.stream_console();
      }
      runtime::print(")");
      return nil();
    }
  #endif

    explicit lazy_sequence(var t) : thunk(t) {} 
    explicit lazy_sequence(var h, var t) : head(h), thunk(t) {} 

    var cons(var x){
      return obj<lazy_sequence>(x,thunk);
    }
    var first() const {
      return sval();
    }
    var rest() const {
      if (head.is_nil())
        return runtime::rest(run(thunk));
      
      return run(thunk);
    }
  };
#+end_src

#+name: runtime-clojure-sequence-object
#+begin_src clojure :tangle no
  (defn new-lazy-seq [f]
    "__result = obj<lazy_sequence>(f);")

  (defmacro lazy-seq [& body]
    `(~'new-lazy-seq (~'fn [] ~@body)))
#+end_src

**** String

strings are represented as a linked list of characters.

#+name: runtime-clojure-string-object
#+begin_src clojure :tangle no
  (defobject string "ferret/obj/string_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/string_o.h
  class string : public seekable_i {
    var data;
  public:

    size_t type() const { return runtime::type::string; }

    var equals(var other){
      return obj<boolean>(container() == other.cast<string>()->container());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      for(auto it : runtime::range(data))
        runtime::print(number::to<char>(it));
      return nil();
    }
  #endif

    explicit string() : data(nullptr) {} 
    explicit string(var s) : data(s) {} 
    explicit string(const char * str) {
      int length = 0;
      for (length = 0; str[length] != '\0'; ++length);
      for (int i = --length; i >= 0; i--)
        data = runtime::cons(obj<number>((number_t)str[i]),data);
    } 
    explicit string(const char * str,int length) {
      for (int i = --length; i >= 0; i--)
        data = runtime::cons(obj<number>((number_t)str[i]),data);
    } 

    var container() const {
      return data;
    }
    var cons(var x){
      return runtime::cons(x,data);
    }
    var first() const {
      return runtime::first(data);
    }
    var rest() const {
      return runtime::rest(data);
    }
    template <typename T>
    static T to(var){
      T::unimplemented_function;
    }

  };

  #ifdef FERRET_STD_LIB
  template<>
  inline var obj<string>(std::string s) {
    return var(new string(s.c_str(), s.size()));
  }

  template <> ::std::string string::to(var v) { 
    ::std::stringstream ss;
    for(auto it : runtime::range(v.cast<string>()->container()))
      ss << number::to<char>(it);
    return ss.str();
  }
  #endif
#+end_src

**** Boolean

A boolean object,

#+name: runtime-clojure-boolean-object
#+begin_src clojure :tangle no
  (defobject boolean "ferret/obj/boolean_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/boolean_o.h
  class boolean : public object_t {
    bool value;
  public:

    size_t type() const { return runtime::type::boolean; }

    var equals(var o){
      return obj<boolean>(value == (bool)o);
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      if (value)
        runtime::print("true");
      else
        runtime::print("false");
      return nil();
    }
  #endif

    explicit boolean(bool b) : value(b) {} 

    bool container() const {
      return value;
    }
  };

  var::operator bool() const {
    if (m_ptr == nullptr)
      return false;
    else if (m_ptr->type() == runtime::type::boolean)
      return static_cast<boolean*>(m_ptr)->container();
    else
      return true;
  }

  var var::equals (var rhs){
    if ( ( is_nil() && !rhs.is_nil()) ||
         (!is_nil() &&  rhs.is_nil()))
      return obj<boolean>(false);

    if (get() == rhs.get())
      return obj<boolean>(true);
    
    if (runtime::is_seqable(*this) && runtime::is_seqable(rhs))
      return get()->equals(rhs);
    else if (m_ptr->type() != rhs.cast<object_t>()->type())
      return obj<boolean>(false);
    else
      return get()->equals(rhs);
  }
#+end_src

**** Atom

Mimics Clojure's /atom/. It is thread safe when used on system where
=FERRET_STD_LIB= is defined.

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defobject atomic_reference "ferret/obj/atom_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/atom_o.h
  class atomic_reference : public object_t {
    var data;
    FERRET_NEW_LOCK(lock)
    public:


    size_t type() const { return runtime::type::atomic_reference; }

    var equals(var o){
      return obj<boolean>(this == o.cast<atomic_reference>());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("atom <");
      data.stream_console();
      runtime::print(">");
      return nil();
    }
  #endif

    explicit atomic_reference(var d) : data(d) {} 

    var swap(var f,var args){
      FERRET_WITH_LOCK(lock,{
          args = runtime::cons(data, args);
          data = f.cast<lambda_i>()->invoke(args);
        });
      return data;
    }
    var deref(){
      FERRET_WITH_LOCK(lock,{
          return data;
        });
    }
  };
#+end_src


Operations on /atoms/

#+name: runtime-clojure-atom-object
#+begin_src clojure :tangle no
  (defn atom [x]
    "__result = obj<atomic_reference>(x)")

  (defn swap! [a f & args]
    "__result = a.cast<atomic_reference>()->swap(f,args);")

  (defn reset! [a newval]
    (swap! a (fn [old curr] curr) newval))

  (defn deref [a]
    "__result = a.cast<atomic_reference>()->deref();")
#+end_src

*** Interfaces

Just like Clojure, Ferret is written in terms of
abstractions. Currently there are abstractions for sequences,
collections and callability.

**** Seekable

All sequence functions use this interface to iterate seekable
containers.

#+name: runtime-clojure-seekable-interface
#+begin_src clojure :tangle no
  (defobject seekable_i "ferret/obj/seekable_i.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/seekable_i.h
  class seekable_i : public object_t {

  public:
    size_t type() const { return runtime::type::seekable_i; }

    virtual var cons(var x) = 0;
    virtual var first() const = 0;
    virtual var rest() const = 0;
  };
#+end_src

C++ API for the interface,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  namespace runtime {
    var list(var v);
    var list(var v);
    template <typename... Args>
    var list(var first, Args... args);

    var first(var coll);
    var rest(var coll);
    var cons(var x, var seq);
    var nth(var seq, var index);
    var nth(var seq, int index);
    size_t count(var seq);
    var is_seqable(var seq);
  }
#+end_src

Range-based for loop support for seekable containers.

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/empty_sequence_o.h
  namespace runtime {
    struct range{
      var p;

      explicit range(var v) : p(v) { }
      inline range begin() const { return range(p); }
      inline range end()   const { return range(obj<empty_sequence>()); }

      inline bool operator!=(const range& other){
        return !p.is_nil() && (p != other.p);
      }

      inline const range& operator++(){
        p = runtime::rest(p);
        return *this;
      }

      inline var operator*(){
        return runtime::first(p);
      }
    };
  }
#+end_src

#+name: runtime-native-implementations
#+begin_src c++ :tangle no
  namespace runtime{
    var first(var coll){
      if (coll.is_nil())
        return nil();
      else
        return coll.cast<seekable_i>()->first();
    }

    var rest(var coll){
      if (coll.is_nil())
        return runtime::list();
      else
        return coll.cast<seekable_i>()->rest();
    }

    var cons(var x, var seq){
      if (seq.is_nil())
        return runtime::list(x);
      if (seq.equals(runtime::list()) == true)
        return runtime::list(x);
      return seq.cast<seekable_i>()->cons(x);
    }

    var nth(var seq, int index){
      int itIdx = 0;
      for(auto it : runtime::range(seq)){
        if (index == itIdx)
          return it;
        itIdx++;
      }
      return nil();
    }
    
    var nth(var seq, var idx){
      return nth(seq,number::to<number_t>(idx));
    }
    
    size_t count(var seq){
      size_t acc = 0;
      for(auto it : runtime::range(seq))
       acc++;
      return acc;
    }

    var is_seqable(var seq){
      if(seq.is_type(runtime::type::sequence) || 
         seq.is_type(runtime::type::lazy_sequence))
        return obj<boolean>(true);
      else
        return obj<boolean>(false);
    }
  }
#+end_src

**** Lambda

Every lambda object implements the /lambda_i/ interface. All lambdas are
executed via /invoke/ method that takes a sequence of vars as argument
or /nil()/ if there are non, this allows us to execute them in a
uniform fashion.

#+name: runtime-clojure-lambda-interface
#+begin_src clojure :tangle no
  (defobject lambda_i "ferret/obj/lambda_i.h")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/lambda_i.h
  class lambda_i : public object_t {
   public:
    virtual var invoke(var args) const = 0;

    size_t type() const { return runtime::type::lambda_i; }

    var equals(var o){
      return obj<boolean>(this == o.cast<lambda_i>());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("lambda"); return nil();
    }
  #endif
  };
#+end_src

Function invocation,

#+name: runtime-native-prototypes
#+begin_src c++ :tangle no
  template<typename T, typename... Args>
  inline var run(T fn, Args... args);
        
  template<typename T>
  inline var run(T fn);

  template<>
  inline var run(var);
#+end_src

#+name: runtime-native-implementations
#+begin_src c++ :tangle no
  template<typename T, typename... Args>
  inline var run(T fn, Args... args) {
    return fn.invoke(runtime::list(args...));
  }

  template<typename T>
  inline var run(T fn) {
    return fn.invoke(nil());
  }

  template<>
  inline var run(var fn) {
    return fn.cast<lambda_i>()->invoke(nil());
  }

  template<typename... Args>
  inline var run(var fn, Args... args) {
    return fn.cast<lambda_i>()->invoke(runtime::list(args...));
  }
#+end_src

** Memory Management

Ferret is designed to be used on embedded systems which means,

 - Latency is more important then through put.
 - Can't have unpredictable GC pauses when running.

So the default memory management is done using reference
counting. Unlike other lisp implementations, Ferret supports various
memory management schemes,

 - *malloc/free* - Allocations are handled by the system
   implementation. (Default memory management.)
 - *Memory Pooling* - On memory constraint systems such as
   microcontrollers Ferret can use a memory pool to avoid heap
   fragmentation and calling malloc/free. Effectively running with
   no heap, allocating all memory at compile time on the stack.
 - *Third party allocators* (i.e tcmalloc)

To enable memory pooling,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_SIZE 256)
#+END_EXAMPLE

This will create a pool object as a global variable that holds an
array of *256 / sizeof(long)*. 

By default page size is =sizeof(long)=. This can be changed using,

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_MEMORY_POOL_PAGE_TYPE char)
#+END_EXAMPLE

Memory pooling is intended for embedded systems where calling
malloc/free is not desired.

Steps for using *tcmalloc* on Mac OS X, install dependencies, 

#+BEGIN_EXAMPLE
  brew install google-perftools
#+END_EXAMPLE

Then from your program you can link to it using,

#+begin_src clojure
  (configure-ferret! :compiler-options ["-std=c++11"
                                        "-L/usr/local/Cellar/gperftools/2.4/lib/"
                                        "-ltcmalloc"])
#+end_src

*** Object Allocation

All object allocations are done using *obj* function. It will return a
new *var* containing a pointer to an [[Object System][Object]]. *nil* is represented as a
*var* pointing to *nullptr*.

#+BEGIN_EXAMPLE
  var two = obj<number>(2);
  var some_nil = nil();
#+END_EXAMPLE

#+name: runtime-native-object-allocation
#+begin_src c++ :tangle no
  template<typename FT, typename... Args>
  inline var obj(Args... args) {
    return var(new FT(args...));
  }

  inline var nil(){
    return var();
  }
#+end_src

*** Reference Counting

Garbage collection is handled by reference counting. Reference count
is kept within the [[Base][obj::base]] using one of the following reference
counting policies.

 - atomic_rc - Atomic reference counting. (using =std::atomic=)
 - rc - Non Atomic reference counting. (using =size_t=)
 - no_rc - No reference counting.

#+name: runtime-native-reference-counting
#+begin_src c++ :tangle no
  namespace mem {
    namespace gc {
  #if defined(FERRET_STD_LIB)
      class atomic_rc{
      public:
        explicit atomic_rc(size_t start) : ref_count(start) { }
        explicit atomic_rc(const atomic_rc& other){ ref_count.exchange(other.ref_count); }
      
        inline void inc_ref() { ref_count++; }
        inline bool dec_ref() { return (--ref_count == 0); }

        atomic_rc &operator=(const atomic_rc &other) {
          ref_count.exchange(other.ref_count);
          return *this;
        }
        
      private:
        ::std::atomic<size_t> ref_count;
      };
  #endif

      class rc{
      public:
        explicit rc(size_t start) : ref_count(start) { }
        explicit rc(const rc& other){ ref_count = other.ref_count; }
      
        inline void inc_ref() { ref_count++; }
        inline bool dec_ref() { return (--ref_count == 0); }

        rc &operator=(const rc &other) { ref_count = other.ref_count; return *this; }
      
      private:
        size_t ref_count;
      };

      class no_rc{
      public:
        explicit no_rc(size_t) { }
        explicit no_rc(const no_rc& ){ }
      
        inline void inc_ref() { }
        inline bool dec_ref() { return false; }

        no_rc &operator=(const no_rc &) { return *this; }
      };
    }
  }
#+end_src 

A /var/ holds a pointer to an object_t, everything is passed around as
/vars/ it is responsible for incrementing/decrementing the reference
count, when it reaches zero it will automatically free the object_t.

#+name: runtime-native-var
#+begin_src c++ :tangle no
  class boolean;

  class var{
  public:
    explicit var(object_t* ptr = nullptr) : m_ptr(ptr) { inc_ref(); }

    var(const var& p) : m_ptr(p.m_ptr) { inc_ref(); }
      
    ~var() { dec_ref(); }
    
    var& operator= (const var& p){
      return *this = p.m_ptr;
    }
    
    var& operator= (object_t* ptr){
      if (m_ptr != ptr){
        dec_ref();
        m_ptr=ptr;
        inc_ref();
      }
      return *this;
    }

    var equals (var rhs);

    bool operator==(const var& other) {
      return (bool)equals(other);
    }

    bool operator!=(const var& other) {
      return !((bool)equals(other));
    }
    
    operator bool() const;

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      if (m_ptr != nullptr )
        m_ptr->stream_console();
      else
        runtime::print("nil");
      return var();
    }
  #endif
        
    inline object_t* get() const { return m_ptr; }
    
    template<typename T>
    inline T* cast() const { return static_cast<T*>(m_ptr); }

    inline bool is_type(size_t type) const { 
      return (static_cast<object_t*>(m_ptr)->type() == type);
    }

    inline bool is_nil() const { 
      return (m_ptr == nullptr);
    }

  private:
    inline void inc_ref(){
      // Only change if non-null
      if (m_ptr) m_ptr->inc_ref();
    }
      
    inline void dec_ref(){
      // Only change if non-null
      if (m_ptr){
        // Subtract and test if this was the last pointer.
        if (m_ptr->dec_ref()){
          delete m_ptr;
          m_ptr = nullptr;
        }
      }
    }
      
    object_t* m_ptr;
  };
#+end_src

*** Memory Allocation

Ferret supports various memory allocation schemes,

 - *malloc/free* - Allocations are handled by the system
   implementation. (Default memory management.)
 - *Memory Pooling* - On memory constraint systems such as
   microcontrollers Ferret can use a memory pool to avoid heap
   fragmentation and calling malloc/free. Effectively running with
   no heap, allocating all memory at compile time on the stack.
 - *Third party allocators* (i.e tcmalloc)
 - *Third party garbage collectors* (i.e The Boehm-Demers-Weiser
   conservative garbage collector.)

**** Default Allocator

[[Object]]s are allocated from system implementation.

#+name: runtime-native-memory-system-allocator
#+begin_src c++ :tangle no
  namespace mem{
    namespace allocator{
      class system{
      public:
        inline void* operator new(size_t size){ return ::malloc(size); }
        inline void  operator delete(void * ptr){ ::free(ptr); }
      };
    }
  }
#+end_src 

**** Pool Allocator

When =FERRET_MEMORY_POOL_SIZE= is defined Ferret programs will use a
memory pool called =mem::allocator::program_memory= instead of
/mallac/,/free/ for memory allocation, depending on the pool size
Ferret will allocate /N/ bytes of memory on stack and all memory
allocation happens in this memory pool useful when working with very
limited amount of memory, such as micro controllers where you want
complete control over the memory and you need deterministic timing
requirements.

#+name: runtime-native-memory-pool-allocator
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE

   #if !defined(FERRET_MEMORY_POOL_PAGE_TYPE)
    #define FERRET_MEMORY_POOL_PAGE_TYPE long
    #define FERRET_MEMORY_POOL_PAGE_COUNT                                   \
      (FERRET_MEMORY_POOL_SIZE / sizeof(FERRET_MEMORY_POOL_PAGE_TYPE))
   #else
    #define FERRET_MEMORY_POOL_PAGE_COUNT FERRET_MEMORY_POOL_SIZE
   #endif

  namespace mem{
    namespace allocator{
      memory_pool<FERRET_MEMORY_POOL_PAGE_TYPE, FERRET_MEMORY_POOL_PAGE_COUNT> program_memory;

      class pool{
      public:
        inline void* operator new(size_t size){ return program_memory.allocate(size); }
        inline void  operator delete(void * ptr){ program_memory.free(ptr); }
      };
    }
  }
  #endif
#+end_src 

When /allocate/ is called the pool will scan the memory pool using
the /used/ bit array to find a block of memory big enough to
satisfy the request. If found, it will the mark the region as used and
return a pointer from /pool/ array to the user which points to
the memory block.

When a free request is received, we resolve the pointer in to the
memory pool read the book keeping information on how much memory
is allocated to this pointer and set these pages to unused.

Memory pool has several advantages, it will avoid fragmentation,
function related to each other will always keep their data close
to each other in the array which improves data locality.

#+name: runtime-native-memory-pool-allocator-implementation
#+begin_src c++ :tangle no
  #ifdef FERRET_MEMORY_POOL_SIZE
  namespace mem{
    namespace allocator{
      template<size_t pool_size>
      class bit_array {
      private:
        uint8_t bits[pool_size / 8 + 1];

        inline size_t index(size_t i){
          return i / 8;
        }

        inline size_t offset(size_t i){
          return i % 8;
        }

      public:
        bit_array() : bits{ false } { }

        inline void set(size_t b){
          bits[index(b)] |= 1 << (offset(b));
        }

        inline void clear(size_t b){
          bits[index(b)] &= ~(1 << (offset(b)));
        }

        inline int get(size_t b){
          return (bits[index(b)] & (1 << (offset(b))));
        }
      };

      template<typename page_size, size_t pool_size>
      class memory_pool{
      public:
        bit_array<pool_size> used;
        page_size pool[pool_size];
        size_t offset;
        FERRET_NEW_LOCK(lock)

        memory_pool() : pool{0}, offset(0) { }

        inline size_t chunk_length(size_t size){
          size_t d = (size / sizeof(page_size));
          size_t f = (size % sizeof(page_size));

          if (f == 0)
            return d;
          else
            return (d + 1);
        }

        inline bool chunk_usable(size_t begin, size_t end){
          for(size_t i=begin; i < end; i++)
            if (used.get(i) != 0)
              return false;
          return true;
        }

        inline size_t next_page(size_t begin){
          for(size_t i=begin; i < pool_size; i++)
            if (used.get(i) == 0)
              return i;
          return pool_size;
        }

        inline int scan_pool(size_t pages_needed, size_t offset = 0){
          for(;;){
            size_t begin = next_page(offset);
            size_t end   = begin + pages_needed;
    
            if (end > pool_size)
              return -1;
          
            if (chunk_usable(begin, end))
              return begin;
    
            offset = end;
          }
        }

        void *allocate(size_t req_size){
          FERRET_WITH_LOCK(lock,{
              size_t length = chunk_length(++req_size);
              int page      = scan_pool(length, offset);

              if (page == -1){
                page = scan_pool(length);
                if (page == -1)
                  return nullptr;
              }
          
              pool[page] = length;
              offset = page + length;
              for(size_t i = page; i < offset; i++)
                used.set(i);

              return &pool[++page];
            });
        }

        void free(void *p){
          FERRET_WITH_LOCK(lock,{
              ptrdiff_t begin = (static_cast<page_size*>(p) - pool) - 1;
              size_t end = begin + pool[begin];

              for(size_t i = begin ; i < end; i++)
                used.clear(i);
            });
        }
      };
    }
  }
  #endif
#+end_src

** Configuration

Ferret defaults to running in safe mode, which means 

  - Multi threading is disabled.
  - Console output is disabled.

Safe mode only requires a C++11 compiler, no third party library is
required including the C++ standard library. Following options can be
configured using /#define/ directives, or using /native-define/ or
/configure-runtime!/ from program code. Unless these options are
overridden in source file, they are auto configured during compilation
on supported platforms. (i.e Multi threading will be enabled on
Linux or Mac OS X.) On unsupported platforms Ferret defaults to
running in safe mode.

#+BEGIN_EXAMPLE
  (configure-runtime! FERRET_DISABLE_STD_OUT true)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  |------------------------------------+--------------+----------------------------------------------------------|
  | Define                             | Defult Value | Description                                              |
  |------------------------------------+--------------+----------------------------------------------------------|
  | FERRET_SAFE_MODE                   | false        | Force Safe Mode.                                         |
  | FERRET_DISABLE_CLI_ARGS            | false        | Disable command line arguments.                          |
  | FERRET_DISABLE_STD_OUT             | false        | Disables output stream. (Reduces code size.)             |
  | FERRET_DISABLE_MULTI_THREADING     | false        | Disable atomic reference counting.                       |
  | FERRET_DISABLE_STD_MAIN            | false        | Disables auto execution of program::run()                |
  | FERRET_DISABLE_RC                  | Not Defined  | Disable Reference Counting. (When using third party GCs) |
  | FERRET_PROGRAM_MAIN                | Not Defined  | A function to execute after program::run()               |
  | FERRET_UART_RATE                   | 9600         | Set default UART rate.                                   |
  | FERRET_HARDWARE_ARDUINO_UART_PORT  | Serial       | Set default UART port.                                   |
  | FERRET_NUMBER_TYPE                 | int          | Default number_t type.                                   |
  | FERRET_REAL_TYPE                   | double       | Default real_t type.                                     |
  | FERRET_REAL_EPSILON                | 0.00001      | Least significant digit representable.                   |
  |------------------------------------+--------------+----------------------------------------------------------|
#+END_EXAMPLE

** Initialization
*** Detect Hardware

Check for supported hardware or platform. If running on a known
hardware or platform break out of *Safe Mode* and set a flag
indicating platform.

#+name: runtime-native-hardware-detect
#+begin_src c++ :tangle no
  # define FERRET_CONFIG_SAFE_MODE TRUE

  #if !defined(FERRET_SAFE_MODE)
    #if defined(__APPLE__) ||                       \
      defined(_WIN32) ||                            \
      defined(__linux__) ||                         \
      defined(__unix__) ||                          \
      defined(_POSIX_VERSION)
    
      # undef  FERRET_CONFIG_SAFE_MODE
      # define FERRET_STD_LIB TRUE
    #endif
    
    #if defined(__SAM3X8E__)                                  || \
      defined(__AVR__)                                        || \
      (defined(ARDUINO_SAMD_ZERO) && defined(__SAMD21G18A__)) || \
      defined(TEENSYDUINO)                                    || \
      defined(_VARIANT_ARDUINO_101_X_)

      # define FERRET_HARDWARE_ARDUINO TRUE

      #if !defined(FERRET_HARDWARE_ARDUINO_UART_PORT)
        # define FERRET_HARDWARE_ARDUINO_UART_PORT Serial
      #endif
    #endif
    
    #if defined(FERRET_HARDWARE_ARDUINO)
      # undef  FERRET_CONFIG_SAFE_MODE
      # define FERRET_DISABLE_MULTI_THREADING TRUE
      # define FERRET_DISABLE_STD_MAIN TRUE
    #endif
  #endif

  #if defined(FERRET_CONFIG_SAFE_MODE)
    # define FERRET_DISABLE_MULTI_THREADING TRUE
    # define FERRET_DISABLE_STD_OUT TRUE
  #endif
#+end_src

*** Import libraries

#+name: runtime-native-hardware-includes
#+begin_src c++ :tangle no
  #ifdef FERRET_STD_LIB
   #include <iostream>
   #include <iomanip>
   #include <sstream>
   #include <cstdio>
   #include <cstdlib>
   #include <cstddef>
   #include <atomic>
   #include <mutex>
   #include <cmath>
   #include <vector>
   #include <algorithm>
   #include <chrono>
   #include <thread>
  #endif

  #ifdef FERRET_HARDWARE_ARDUINO
   #include <Arduino.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
  #endif

  #ifdef FERRET_CONFIG_SAFE_MODE
   #include <stdio.h>
   #include <stdlib.h>
   #include <stdint.h>
  #endif
#+end_src

*** Initialize Hardware
    :PROPERTIES:
    :noweb-ref: runtime-native-hardware-initialize
    :END:

Default UART rate (if supported),

#+begin_src c++ :tangle no
  #if !defined(FERRET_UART_RATE)
    # define FERRET_UART_RATE 9600
  #endif
#+end_src

Setup dummy IO,

#+begin_src c++ :tangle no
  #if defined(FERRET_DISABLE_STD_OUT)
     namespace runtime{
       void init(){ }
      
       template <typename T>
       void print(T){ }
     }
  #endif
#+end_src

Setup IO for general purpose OS,

#+begin_src c++ :tangle no
  #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_STD_OUT)
    namespace runtime{
      void init(){}
      
      template <typename T>
      void print(const T t){ std::cout << t; }

      template <>
      void print(const real_t n){
        std::cout << std::fixed << std::setprecision(number_precision) << n;
      }
    }
  #endif
#+end_src

Setup IO for Arduino boards,

#+begin_src c++ :tangle no
  #if defined(FERRET_HARDWARE_ARDUINO) && !defined(FERRET_DISABLE_STD_OUT) 
    namespace runtime{
      void init(){ FERRET_HARDWARE_ARDUINO_UART_PORT.begin(FERRET_UART_RATE); }

      template <typename T>
      void print(const T t){ FERRET_HARDWARE_ARDUINO_UART_PORT.print(t); }

      template <>
      void print(void* p){
        FERRET_HARDWARE_ARDUINO_UART_PORT.print((size_t)p,HEX);
      }
     }
  #endif
#+end_src

*** Program Run

Unless =FERRET_DISABLE_STD_MAIN= is *defined* a =main= function is
defined which is the designated start of the
program. =program::run()= function contains all compiled
code. Executing this function has equivalent semantics to loading the
Clojure source file into a virgin Clojure interpreter and then
terminating its execution. If =FERRET_PROGRAM_MAIN= is defined, it
will be called right after =program::run()=.

#+name: runtime-native-program-run-std-main
#+begin_src c++ :tangle no
  #if !defined(FERRET_DISABLE_STD_MAIN)
   #if defined(FERRET_DISABLE_CLI_ARGS) || !defined(FERRET_STD_LIB)
    int main()
   #else
    int main(int argc, char* argv[])
   #endif
    {
      using namespace ferret;

     #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_CLI_ARGS)
      for (int i = argc - 1; i > -1 ; i--)
        _star_command_line_args_star_ =  runtime::cons(obj<string>(argv[i]),_star_command_line_args_star_);
     #endif

      program::run();

     #if defined(FERRET_PROGRAM_MAIN)
      run(FERRET_PROGRAM_MAIN);
     #endif
       
      return 0;
    }
  #endif
#+end_src

When a supported Arduino board is [[Detect Hardware][detected]]. Instead of using a
standard =main= function, Ferret uses Arduino compatible boot
procedure. 

#+name: runtime-native-program-arduino
#+begin_src c++ :tangle no
  #if defined(FERRET_HARDWARE_ARDUINO)
    void setup(){
      using namespace ferret;

        runtime::init();

      #if defined(FERRET_PROGRAM_MAIN)
        program::run();
      #endif
    }
    void loop(){
      using namespace ferret;
      #if !defined(FERRET_PROGRAM_MAIN)
        program::run();
      #endif          

      #if defined(FERRET_PROGRAM_MAIN)
        run(FERRET_PROGRAM_MAIN);
      #endif
    }
  #endif
#+end_src

*** Configure Locking

Locking macros. They are disabled when running single threaded or on
an embedded platform. (=FERRET_STD_LIB= not defined.)

#+name: runtime-native-locking-macros
#+begin_src c++ :tangle no
  #if defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_MULTI_THREADING)
   #define FERRET_NEW_LOCK(symbol) ::std::mutex symbol;
   #define FERRET_WITH_LOCK(lock,code)                           \
     {                                                           \
     ::std::lock_guard< ::std::mutex > ferret_scope_guard(lock); \
     code;                                                       \
     }
  #else
   #define FERRET_NEW_LOCK(symbol)
   #define FERRET_WITH_LOCK(lock,code) code;
  #endif
#+end_src

** Accessing C,C++ Libraries

Ferret's FFI is modeled after Gambit scheme. Whereas Gambit scheme
lets you embed C into Scheme, Ferret lets you embed C or C++ into
Clojure.

Native headers can be imported using,

#+begin_src clojure
  (native-header "thirt_party_header.h")
#+end_src

Top level statements can be declared using,

#+begin_src clojure
  (native-declare "int i = 0;")
#+end_src

Ferret objects can be created using the /obj/ function. If a function
only contains a string such as, 

#+begin_src clojure
  (defn inc-int [] "__result =  obj<number>(i++);")
#+end_src

It is assumed to be a native function string, it is taken as C++
code. You can then use it like any other ferret function.

#+begin_src clojure
  (while (< (inc-int) 10)
    (print 1))
#+end_src

Another option is to use the *cxx* macro,

#+begin_src clojure
  (def dac-0 (cxx "__result =  obj<number>(DAC0);"))
#+end_src

Ferret objects can be converted to/from their native counter parts,
i.e a Ferret sequence can be converted to /std::vector/ to be sorted
by /std::sort/ using a Ferret function,

#+name: ffi-test-helper
#+begin_src clojure
  (defn my-sort [f seq]
    "std_vector vec = sequence::to<std_vector>(seq);
     std::sort(vec.begin(), vec.end(), [f](var a, var b) { return run(f,a,b); });
     __result = sequence::from<std_vector>(vec);")
#+end_src

#+begin_src clojure
  (my-sort > (list 1 3 2)) ;; (1.0000 2.0000 3.0000)
  (my-sort < (list 1 3 2)) ;; (3.0000 2.0000 1.0000)
#+end_src

#+name: ffi-test-helper
#+begin_src clojure
  (defn my-find [item seq]
    "std_vector vec = sequence::to<std_vector>(seq);
     std_vector::iterator it = find (vec.begin(), vec.end(), item);

     if(it != vec.end())
       __result = obj<boolean>(true);")
#+end_src

#+begin_src clojure
  (my-find (list 1 2) (list (list 1 2)
                            (list 2 3)
                            (list 4 5)))

  ;; true

  (my-find (list 5 5) (list (list 1 2)
                            (list 2 3)
                            (list 4 5)))

  ;; false
#+end_src

In addition to *defn* form there is also a *defnative* form which
allows you to define different function bodies for different *#define*
directives,

#+name: runtime-clojure-get-char
#+begin_src clojure
  (defnative get-char []
    (on "defined FERRET_STD_LIB"
        "__result = obj<number>(getchar());"))
#+end_src

This function when compiled on a system that defines =GNU_GCC= will
return the result of *getchar* as a *number* , on ANY other system it
will return *nil*. You can have multiple *on* blocks per *defnative*,

#+name: runtime-clojure-sleep
#+begin_src clojure
  (defnative sleep [t]
    (on "defined FERRET_STD_LIB"
        "auto duration = ::std::chrono::milliseconds(number::to<number_t>(t));
         ::std::this_thread::sleep_for(duration);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delay(number::to<number_t>(t));"))
#+end_src

This way a single function can be defined for multiple
systems. Reverse is also possible, since all built in data structures
are immutable you can freely call Ferret code from C++,

#+begin_src c++
  var alist = runtime::list(obj<number>(1),obj<number>(2),obj<number>(3));

  int sum = 0;
  for(auto it : runtime::range(alist)){
    sum += number::to<int>(it);
   }

  ::std::cout << sum << ::std::endl;

  //or

  var res = _plus_().invoke(alist);
  res.stream_console();
  ::std::cout << ::std::endl;
#+end_src

* Clojure Core

Once our object system is in place we can define rest of the runtime
(functions/macros) using our Clojure subset,

#+name: runtime-clojure-first
#+begin_src clojure :tangle no
  (defn first [x]
    "__result = runtime::first(x);")

  (defn second [x]
    "__result = runtime::first(runtime::rest(x));")

  (defn nil? [x] "__result = obj<boolean>(x.is_nil())")
#+end_src

We can embed C++ code into our functions, which is how most of the
primitive functions are defined such as the /first/ function above,
once primitives are in place rest can be defined in pure Clojure,

#+name: runtime-clojure-println
#+begin_src clojure :tangle no
  (defn println [& more]
    (when more
      (apply print more))
    (newline))
#+end_src

As for macros, normal Clojure rules apply since they are expended using
Clojure, the only exception is that stuff should not expand to fully
qualified Clojure symbols, so the symbol /fn/ should not expand to
/clojure.core/fn/,


#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defn [name & body]
    `(~'def ~name (~'fn ~@body)))
#+end_src

** Functions

Multi arity functions are handled by the /fn/ macro. There are two
ways to define a function. For single arity functions it accepts the
following form,

#+begin_src clojure :tangle no
  (fn [a] a)
#+end_src

For multi arity functions it expects the following form,

#+begin_src clojure :tangle no
  (fn
    ([a] 1)
    ([a b] 2)
    ([a b & c] 3)
    ([a b [c d] & e] 4))
#+end_src

A multi arity function is a function that counts the number of its
arguments and then dispatches on the number of arguments to each
implementation.

#+name: runtime-clojure-fn-macro
#+begin_src clojure :tangle no
  (defmacro fn [& body]
    (if (vector? (first body))
      (unique-fn body)
      (let [fns (map #(unique-fn %) body)
            conds (->> (map first body)
                       (map (fn* [args] (filter #(not (= % '&)) args)))
                       (map #(count %)))
            form (if (pos? (.indexOf (last (map first body)) '&))
                   (let [conds (interleave conds fns)
                         arg-dispatch (drop-last 2 conds)
                         last (take-last 2 conds)]
                     (concat arg-dispatch [true (second last)]))
                   (interleave conds fns))]
        `(~'fn* (& (~'ferret-compiler-no-closure fn-arg-symbol#))
                (~'fir-dispatch-lambda fn-arg-symbol# ~@form)))))
#+end_src

A simple macro for calling inline C++,

#+name: runtime-clojure-fn-macro
#+begin_src clojure :tangle no
  (defmacro cxx [str]
    `((~'fn [] ~str)))
#+end_src

** I/O
*** print

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative print [& more]
    (on "!defined(FERRET_DISABLE_STD_OUT)"
        "if (more.is_nil())
           return nil();
         var f = runtime::first(more);
         f.stream_console();
         var r = runtime::rest(more);
         for(auto it : runtime::range(r)){
          runtime::print(\" \");
          it.stream_console();
         }"))
#+end_src

*** newline

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative newline [& more]
    (on "!defined(FERRET_DISABLE_STD_OUT)"
        "runtime::print(\"\\n\");"))
#+end_src

*** println

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  <<runtime-clojure-println>>
#+end_src

*** get-char

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no :noweb yes
  <<runtime-clojure-get-char>>
#+end_src

*** sh

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defnative sh [cmd]
    (on "defined FERRET_STD_LIB"
        ("memory")
        "::std::shared_ptr<FILE> pipe(popen(string::to<std::string>(cmd).c_str(), \"r\"), pclose);
         if (!pipe) 
            __result = nil();
         char buffer[128];
         ::std::string result = \"\";
         while (!feof(pipe.get()))
          if (fgets(buffer, 128, pipe.get()) != NULL)
           result += buffer;
         __result = obj<string>(result);"))
#+end_src

*** system-exit

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn system-exit [code]
    "::std::exit(number::to<number_t>(code));")
#+end_src

*** system-abort

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn system-abort [code]
    "::std::abort();")
#+end_src

*** xor-stream-encoder/decoder

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn xor-stream-encoder [write]
    (fn [seq]
      (let [length (count seq)
            checksum (reduce bit-xor length seq)]
        (write 0X06)
        (write 0X85)
        (write length)
        (doseq [s seq] 
          (write s))
        (write checksum))))
#+end_src

#+name: runtime-clojure-console-io
#+begin_src clojure :tangle no
  (defn xor-stream-header-ready [read in-waiting]
    (and (>= (in-waiting) 3) (= (read) 0X06) (= (read) 0X85)))

  (defn xor-stream-payload-ready [payload-size in-waiting]
    (>= (in-waiting) (inc (deref payload-size))))

  (defn xor-stream-decoder-goto [] true)

  (defn xor-stream-decoder [read in-waiting handler]
    (let [payload-size (atom nil)]
      (state-machine 
       (states
        (sync-header)
        (reset-payload    (reset! payload-size (read)))
        (wait-payload)
        (handle-payload   (let [payload (atom (list))]
                            (dotimes [_ (deref payload-size)]
                              (swap! payload conj (read)))
                            (when (= (read) (reduce bit-xor (deref payload-size) (deref payload)))
                              (swap! payload reverse)
                              (handler (deref payload))))))
       (transitions
        (sync-header     #(xor-stream-header-ready read in-waiting)           reset-payload)
        (reset-payload   xor-stream-decoder-goto                              wait-payload)
        (wait-payload    #(xor-stream-payload-ready payload-size in-waiting)  handle-payload)
        (handle-payload  xor-stream-decoder-goto                              sync-header)))))
#+end_src

** Looping
*** doseq

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro doseq [binding & body]
    `(~'_doseq_ ~(second binding)
                (~'fn [~(first binding)] ~@body)))

  (defn _doseq_ [seq f] "for(auto it : runtime::range(seq)) run(f,it);")
#+end_src

*** dotimes

#+name: runtime-clojure-looping
#+begin_src clojure :tangle no
  (defmacro dotimes [binding & body]
    `(~'_dotimes_ ~(second binding)
                  (~'fn [~(first binding)] ~@body)))

  (defn _dotimes_ [t f] "for(number_t i = 0; i < number::to<number_t>(t); i++) run(f,obj<number>(i));")
#+end_src

** Conditionals
*** when

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when [test & body]
    `(~'if ~test (~'do ~@body)))
#+end_src

*** cond

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro cond [& clauses]
    (when clauses
      `(~'if ~(first clauses)
        ~(if (next clauses)
           (second clauses)
           (throw (IllegalArgumentException.
                   "cond requires an even number of forms")))
        (~'cond ~@(next (next clauses))))))
#+end_src

*** while

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defn _while_ [pred fn]
    "while(run(pred))
       run(fn);")

  (defmacro while [test & body]
    `(~'_while_ (~'fn* [] ~test) (~'fn [] ~@body)))
#+end_src

*** forever

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro forever [& body]
    `(~'while true ~@body))
#+end_src

*** if-let

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro if-let
    ([bindings then]
     `(~'if-let ~bindings ~then nil))
    ([bindings then else & oldform]
     (let [form (bindings 0) tst (bindings 1)]
       `(~'let* [temp# ~tst]
                (~'if temp#
                  (~'let* [~form temp#]
                          ~then)
                  ~else)))))
#+end_src

*** when-let

When test is true, evaluates body with binding-form bound to the value of test.

#+name: runtime-clojure-conditionals
#+begin_src clojure :tangle no
  (defmacro when-let
    [bindings & body]
    (let [form (bindings 0) tst (bindings 1)]
      `(~'let* [temp# ~tst]
               (~'when temp#
                 (~'let* [~form temp#]
                         ~@body)))))
#+end_src

** Logical Operators
*** =

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn = [& args]
    "var curr = runtime::first(args);
     for(auto it : runtime::range(runtime::rest(args))){
      if (curr.equals(it) == false)
        return obj<boolean>(false);
      curr = it;
     }
     __result = obj<boolean>(true);")
#+end_src

*** not=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro not= [& test]
    `(~'not (~'= ~@test)))
#+end_src

*** <

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn <
    ([] true)
    ([x] true)
    ([a b]
     "__result = a.cast<number>()->is_smaller(b);")
    ([a b & more]
     (if (< a b)
       (apply < (cons b more))
       false)))
#+end_src

*** >

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn >
    ([] true)
    ([x] true)
    ([a b]
     "__result = a.cast<number>()->is_bigger(b);")
    ([a b & more]
     (if (> a b)
       (apply > (cons b more))
       false)))
#+end_src

*** >=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn >=
    ([] true)
    ([x] true)
    ([a b]
     "__result = a.cast<number>()->is_bigger_equal(b);")
    ([a b & more]
     (if (>= a b)
       (apply >= (cons b more))
       false)))
#+end_src

*** <=

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn <=
    ([] true)
    ([x] true)
    ([a b]
     "__result = a.cast<number>()->is_smaller_equal(b);")
    ([a b & more]
     (if (<= a b)
       (apply <= (cons b more))
       false)))
#+end_src

*** and

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro and
    ([] true)
    ([x] x)
    ([x & next]
     `(~'if ~x (~'and ~@next) false)))
#+end_src

*** or

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defmacro or
    ([] nil)
    ([x] x)
    ([x & next]
     `(~'if ~x ~x (~'or ~@next))))
#+end_src

*** not

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn not [x]
    "if (x)
       return obj<boolean>(false);
     __result = obj<boolean>(true);")
#+end_src

*** true?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn true? [x]
    "if (x)
       return obj<boolean>(true);
     __result = obj<boolean>(false);")
#+end_src

*** false?

#+name: runtime-clojure-logical-operators
#+begin_src clojure :tangle no
  (defn false? [x]
    "if (!x)
       return obj<boolean>(true);
     __result = obj<boolean>(false);")
#+end_src

** Sequence
*** map

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn map [f col]
    (if (not (empty? col))
      (cons (f (first col))
            (lazy-seq (map f (rest col))))))
#+end_src

*** range

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn range
    ([high]
     (range 0 high))
    ([low high]
     (if (< low high)
       (cons low (lazy-seq
                  (range (inc low) high))))))
#+end_src

*** take

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn take [n coll]
    (if (not (empty? coll))
      (if (> n 0)
        (cons (first coll)
              (lazy-seq (take (- n 1) (rest coll)))))))
#+end_src

*** take-while

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn take-while [pred s]
    (if (and (not (empty? s))
             (pred (first s)))
      (cons (first s) (lazy-seq (take-while pred (rest s))))))
#+end_src

*** drop

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn drop [n coll]
    (if (and (pos? n)
             (not (empty? coll)))
      (drop (dec n) (rest coll))
      coll))
#+end_src

*** concat

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn concat
    ([]
     (list))
    ([x]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x))))))
    ([x y]
     (if (not (empty? x))
       (cons (first x) (lazy-seq (concat (rest x) y)))
       (concat y))))
#+end_src

*** reduce

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reduce
    ([f [sf & sr]]
     "var acc = run(f, runtime::first(sr), sf);
      var r = runtime::rest(sr);
      for (auto i : runtime::range(r))
       acc = run(f, acc, i);
      __result = acc;")
    ([f acc coll]
     "for (auto i : runtime::range(coll))
       acc = run(f, acc, i);
      __result = acc;"))
#+end_src

*** list

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list [& xs] "if (xs.is_nil())
                       __result = runtime::list();
                     else
                       __result = xs;")
#+end_src

*** list?

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn list? [x] "__result = obj<boolean>(x.is_type(runtime::type::sequence));")
#+end_src

*** empty?

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn empty? [x]
    (if (nil? x)
      true
      (= (list ) x)))
#+end_src

*** rest

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn rest [x] "var r = runtime::rest(x);
                  if (r.is_nil())
                    return runtime::list();
                  else 
                    __result = r;")
#+end_src

*** nth

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn nth [coll index] "__result = runtime::nth(coll,index);")
#+end_src

*** nthrest

Returns the nth rest of coll, coll when n is 0.

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn nthrest [coll n]
    "__result = coll;
     for(number_t i = 0; i < number::to<number_t>(n); i++)
       __result = runtime::rest(__result);

     if (__result.is_nil())
       __result = runtime::list();")
#+end_src

*** cons

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn cons [x seq] "__result = runtime::cons(x, seq);")
#+end_src

*** apply

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn apply [f args] "__result = f.cast<lambda_i>()->invoke(args);")
#+end_src

*** conj

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn conj [coll & xs]
    (reduce (fn[h v] (cons v h)) (if (nil? coll) (list) coll) xs))
#+end_src

*** reverse

#+name: runtime-clojure-sequence
#+begin_src clojure :tangle no
  (defn reverse [s]
    (reduce (fn[h v] (cons v h)) (list) s))
#+end_src

*** count

#+name: runtime-clojure-sequence-count
#+begin_src clojure :tangle no
  (defn count [s]
    (if (or (nil? s)
            (empty? s))
      0
      (reduce inc 0 s)))
#+end_src

*** filter

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn filter [pred coll]
    (if (not (empty? coll))
      (let [[f & r] coll]
        (if (pred f)
          (cons f (filter pred r))
          (filter pred r)))
      coll))
#+end_src

*** repeatedly

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn repeatedly
    ([f] (cons (f) (lazy-seq (repeatedly f))))
    ([n f] (take n (repeatedly f))))
#+end_src

*** partition

#+name: runtime-clojure-sequence-lazy
#+begin_src clojure :tangle no
  (defn partition
    ([n coll]
     (partition n n coll))
    ([n step coll]
     (lazy-seq
      (if (not (empty? coll))
        (let [p (take n coll)]
          (when (= n (count p))
            (cons p (partition n step (nthrest coll step))))))))
    ([n step pad coll]
     (lazy-seq
      (if (not (empty? coll))
        (let [p (take n coll)]
          (if (= n (count p))
            (cons p (partition n step pad (nthrest coll step)))
            (list (take n (concat p pad)))))))))
#+end_src

** Math
*** zero?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn zero? [x]
    (= x 0))
#+end_src

*** pos?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn pos? [x]
    (> x 0))
#+end_src

*** neg?

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn neg? [x]
    (< x 0))
#+end_src

*** +

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn +
    ([] 0)
    ([x] x)
    ([h v]
     "__result = h.cast<number>()->add(v);")
    ([x y & more]
     (reduce + (+ x y) more)))
#+end_src

*** -

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn -
    ([x]
     (* -1 x))
    ([h v]
     "__result = h.cast<number>()->sub(v);")
    ([x y & more]
     (reduce - (- x y) more)))
#+end_src

*** *

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn *
    ([] 1)
    ([x] x)
    ([h v]
     "__result = h.cast<number>()->mul(v);")
    ([x y & more]
     (reduce * (* x y) more)))
#+end_src

*** /

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn /
    ([x]
     (apply / (list 1 x)))
    ([h v]
     "__result = h.cast<number>()->div(v);")
    ([x y & more]
     (reduce / (/ x y) more)))
#+end_src

*** inc

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn inc [x]
    (+ x 1))
#+end_src

*** dec

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn dec [x]
    (- x 1))
#+end_src

*** count

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  <<runtime-clojure-sequence-count>>
#+end_src

*** min / max

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn min
    ([x] x)
    ([x & r]
     (reduce (fn[h v]
               (if (< h v)
                 h v))
             x r)))

  (defn max
    ([x] x)
    ([x & r]
     (reduce (fn[h v]
               (if (> h v)
                 h v))
             x r)))
#+end_src

*** rem

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn rem [num div]
    "__result = obj<number>(remainder(number::to<real_t>(num), number::to<real_t>(div)));")
#+end_src

*** mod

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn mod [num div] 
    (let [m (rem num div)] 
      (if (or (zero? m) (= (pos? num) (pos? div)))
        m 
        (+ m div))))
#+end_src

*** floor

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn floor [x] "__result = obj<number>(number::to<number_t>(x));")
#+end_src

*** scale

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn scale [x in-min in-max out-min out-max]
    (+ (/ (* (- x in-min) (- out-max out-min)) (- in-max in-min)) out-min))
#+end_src

*** clamp

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn clamp [x min max]
    (cond
      (> x max) max
      (< x min) min
      true x))
#+end_src

*** bit-and

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-and [x y] "__result = obj<number>((number::to<number_t>(x) & number::to<number_t>(y)));")
#+end_src

*** bit-not

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-not [x] "__result = obj<number>(~number::to<number_t>(x));")
#+end_src

*** bit-or

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-or [x y] "__result = obj<number>((number::to<number_t>(x) | number::to<number_t>(y) ));")
#+end_src

*** bit-xor

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-xor [x y] "__result = obj<number>((number::to<number_t>(x) ^ number::to<number_t>(y) ));")
#+end_src

*** bit-shift-left

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-left [x n] "__result = obj<number>((number::to<number_t>(x) << number::to<number_t>(n) ));")
#+end_src

*** bit-shift-right

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn bit-shift-right [x n] "__result = obj<number>((number::to<number_t>(x) >> number::to<number_t>(n) ));")
#+end_src

*** number-split

Split a number into bytes.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn number-split [n]
    "number_t val = number::to<number_t>(n);
     unsigned char *p = (unsigned char*)&val;
     __result = runtime::list();
     for(size_t i = 0; i < sizeof(number_t); i++)
       __result = runtime::cons(obj<number>((number_t)p[i]),__result);")
#+end_src

*** number-combine

Combine a list of bytes to a number.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn number-combine [s]
    "number_t res = 0;
     for(size_t i = 0; i < sizeof(number_t); i++){
      int idx = (sizeof(number_t) - i - 1);
      var obj = runtime::nth(s,idx);
      number_t val = number::to<number_t>(obj);
      res |= val << (i * 8);
     }
     __result = obj<number>(res);")
#+end_src

*** sqrt

Square root.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn sqrt [s]
    "__result = obj<number>((real_t)::sqrt(number::to<real_t>(s)));")
#+end_src

*** pow

Returns base raised to the power exponent:

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn pow [b e]
    "__result = obj<number>((real_t)::pow(number::to<real_t>(b), number::to<real_t>(e)));")
#+end_src

*** cos

Returns the cosine of an angle of x radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn cos [s]
    "__result = obj<number>((real_t)::cos(number::to<real_t>(s)));")
#+end_src

*** sin

Returns the sine of an angle of x radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn sin [s]
    "__result = obj<number>((real_t)::sin(number::to<real_t>(s)));")
#+end_src

*** asin

 Returns the principal value of the arc sine of x, expressed in radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn asin [x]
    "__result = obj<number>((real_t)::asin(number::to<real_t>(x)));")
#+end_src

*** atan2

Returns the principal value of the arc tangent of y/x, expressed in radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn atan2 [x y]
    "__result = obj<number>((real_t)::atan2(number::to<real_t>(x),number::to<real_t>(y)));")
#+end_src

*** log / log10

Returns the natural logarithm of x.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn log [x]
    "__result = obj<number>((real_t)::log(number::to<real_t>(x)));")
#+end_src

Returns the natural logarithm of x.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn log10 [x]
    "__result = obj<number>((real_t)::log10(number::to<real_t>(x)));")
#+end_src

*** to-degrees

Converts an angle measured in radians to an approximately equivalent
angle measured in degrees.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn to-degrees [x]
    "__result = obj<number>((real_t) (number::to<real_t>(x) * 180.0 / M_PI) );")
#+end_src

*** to-radians

Converts an angle measured in degrees to an approximately equivalent
angle measured in radians.

#+name: runtime-clojure-math
#+begin_src clojure :tangle no :noweb yes
  (defn to-radians [x]
    "__result = obj<number>((real_t) (number::to<real_t>(x) * M_PI / 180.0) );")
#+end_src

** Concurrency
*** thread

Runs the given lambda in a thread,

#+name: runtime-clojure-bit-operations
#+begin_src clojure :tangle no
  (defnative thread [f]
    (on "defined(FERRET_STD_LIB) && !defined(FERRET_DISABLE_MULTI_THREADING)"
        "::std::thread ([f](){return run(f);}).detach();"))
#+end_src

** Timing
*** millis

Return current time in milliseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative millis []
    (on "defined FERRET_STD_LIB"
        "auto now = ::std::chrono::system_clock::now();
         auto epoch = now.time_since_epoch();
         auto time = ::std::chrono::duration_cast<::std::chrono::milliseconds>(epoch).count();
         __result = obj<number>(time);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<number>(::millis());"))
#+end_src

*** micros

Return current time in microseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative micros []
    (on "defined FERRET_STD_LIB"
        "auto now = ::std::chrono::high_resolution_clock::now();
         auto epoch = now.time_since_epoch();
         auto time = ::std::chrono::duration_cast<::std::chrono::microseconds>(epoch).count();
         __result = obj<number>(time);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<number>(::micros());"))
#+end_src

*** sleep

Sleep current thread for *t* milliseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no :noweb yes
  <<runtime-clojure-sleep>>
#+end_src

*** sleep-micros

Sleep current thread for *t* microseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no :noweb yes
  (defnative sleep-micros [t]
    (on "defined FERRET_STD_LIB"
        "auto duration = ::std::chrono::microseconds(number::to<number_t>(t));
         ::std::this_thread::sleep_for(duration);")
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::delayMicroseconds(number::to<real_t>(t));"))
#+end_src

*** elapsed-micros

Port of Teensy elapsedMicros API,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no :noweb yes
  (defobject elapsed_micros "ferret/obj/elapsed_micros_o.h")

  (defn new-elapsed-micros []
    "__result = obj<elapsed_micros>();")

  (defn elapsed-micros? [t r]
    "__result = obj<boolean>(t.cast<elapsed_micros>()->is_elapsed(number::to<real_t>(r)));")

  (defn elapsed-micros-now [t]
    "__result = obj<number>(t.cast<elapsed_micros>()->elapsed());")

  (defn elapsed-micros-reset [t]
    "t.cast<elapsed_micros>()->reset()")
#+end_src

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/obj/elapsed_micros_o.h
  class elapsed_micros : public object_t {
   private:
    unsigned long us;
   public:

    elapsed_micros(void) { us = now(); }
    void reset() { us = now(); }
    
    size_t type() const { return runtime::type::elapsed_micros; }

    var equals(var o){
      return obj<boolean>(this == o.cast<elapsed_micros>());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("elapsed_micros<");
      runtime::print(_elapsed());
      runtime::print(">");
      return nil();
    }
  #endif

  #if defined(FERRET_HARDWARE_ARDUINO)
    inline unsigned long now() const{
      return ::micros();
    }
  #elif defined(FERRET_STD_LIB)
    inline unsigned long now() const{
      auto now = ::std::chrono::high_resolution_clock::now();
      auto epoch = now.time_since_epoch();
      return ::std::chrono::duration_cast<::std::chrono::microseconds>(epoch).count();
    }
  #else
    inline unsigned long now() const{
      T::unimplemented_function;
    }  
  #endif

    inline unsigned long _elapsed() const { return (now() - us); }
    inline var elapsed() const { return obj<number>(_elapsed()); }
    inline bool is_elapsed(real_t t) const { return (_elapsed() >= t); }
  };
#+end_src

*** time-fn

Takes a function *f* and returns the number of milliseconds it takes
to run,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn time-fn [f]
    (let [start (millis)]
      (f)
      (- (millis) start)))
#+end_src

*** benchmark

Runs the function *f* *n* times and return the average time it takes
function *f* to run in milliseconds,

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn benchmark [f n]
    (let [values (map (fn [_] (time-fn f)) (range n))]
      (floor (/ (apply + values) n))))
#+end_src

*** fn-throttler

    Returns a new function that limits the throughput of the given
    function. When called faster than ==rate== it can either block or
    return ==nil== immediately.

#+BEGIN_EXAMPLE
  (defn ping []
    (println "Ping!"))

  (def throttled-ping (fn-throttler ping 1 :second :blocking))

  ;; Ping console every second
  (forever
   (throttled-ping))
#+END_EXAMPLE

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn fn-throttler-aux-blocking [timer f rate]
    (fn [& args]
      (let [wait (- rate (elapsed-micros-now timer))]
        (elapsed-micros-reset timer)
        (sleep-micros wait)
        (apply f args))))

  (defn fn-throttler-aux-non-blocking [timer f rate]
    (fn [& args]
      (when (elapsed-micros? timer rate)
        (elapsed-micros-reset timer)
        (apply f args))))

  (defmacro fn-throttler [f rate unit policy]
    (let [unit->ms {:microsecond 1 :millisecond 1000
                    :second 1000000 :minute 60000000
                    :hour 3600000000 :day 86400000000
                    :month 2678400000000}
          rate (/ (unit->ms unit) rate)]
      (if (= policy :blocking)
        `(~'fn-throttler-aux-blocking     (~'new-elapsed-micros) ~f ~rate)
        `(~'fn-throttler-aux-non-blocking (~'new-elapsed-micros) ~f ~rate))))
#+end_src

** Misc
*** rand

Returns a random floating point number between 0 (inclusive) and n
(default 1) (exclusive).

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative rand-aux []
    (on "defined FERRET_STD_LIB"
        ("random")
        "::std::random_device ferret_random_device;
         ::std::mt19937_64 ferret_random_generator(ferret_random_device());
         ::std::uniform_real_distribution<ferret::real_t> ferret_random_distribution(0.0,1.0);"
        "__result = obj<number>(ferret_random_distribution(ferret_random_generator));"))

  (defn rand
    ([]
     (rand-aux))
    ([x]
     (* x (rand-aux))))
#+end_src

*** rand-int

Returns a random integer between 0 (inclusive) and n (exclusive).

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn rand-int
    [x]
    (floor (rand x)))
#+end_src

*** identity

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn identity [x] x)
#+end_src

*** ->>

Threads the expr through the forms. Inserts x as the
last item in the first form, making a list of it if it is not a
list already. If there are more forms, inserts the first form as the
last item in second form, etc.

#+name: runtime-clojure-thread-macro
#+begin_src clojure :tangle no
  (defmacro ->> [x & forms]
    (loop [x x, forms forms]
      (if forms
        (let [form (first forms)
              threaded (if (seq? form)
                         `(~(first form) ~@(next form)  ~x)
                         (list form x))]
          (recur threaded (next forms)))
        x)))
#+end_src

*** doto

Evaluates x then calls all of the methods and functions with the
value of x supplied at the front of the given arguments.  The forms
are evaluated in order.  Returns x.

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defmacro doto
    [x & forms]
    (let [gx (gensym)]
      `(let [~gx ~x]
         ~@(map (fn [f]
                  (if (seq? f)
                    `(~(first f) ~gx ~@(next f))
                    `(~f ~gx)))
                forms)
         ~gx)))
#+end_src

** Control
*** State Machines

This macro allows users to define state machines using the following
DSL,

#+begin_src clojure :tangle no
  (def two-state-machine
    (state-machine 
     (states
      (off :off)
      (on  :on))
     (transitions
      (off (fn [] true) on)
      (on  (fn [] true) off))))

  (dotimes [i 10]
    (let [state (two-state-machine)]
      (if (= state :off)
        (println "Off")
        (println "On"))))
#+end_src

Each transition takes a list of /fn/ /state/ pairs first function that
returns true, returns the next state.

#+name: runtime-clojure-state-machine
#+begin_src clojure :tangle no
  (defmacro state-machine [[_ & states] [_ & transitions]]
    (let [states (reduce (fn [h v]
                           (let [[name & body] v]
                             (conj h name `(~'fn [] ~@body))))
                         [] states)
          transitions (->> transitions
                           (map (fn [v]
                                  (let [[state & conds] v
                                        conds (->> (partition 2 conds)
                                                   (reduce (fn [h v]
                                                             (let [[check state] v]
                                                               (conj h `(~check) state))) []))]
                                    `((~'= ~'state ~state) (~'cond ~@conds true ~state)))))
                           (reduce (fn [h v]
                                     (let [[check transition] v]
                                       (conj h check transition)))
                                   ['cond]))]
      `(let [~@states
             machine-state# (~'atom ~(first states))]
         (~'fn []
          (~'let [ret# ((~'deref machine-state#))]
           (~'swap! machine-state# (~'fn [~'state] (~@transitions)))
           ret#)))))
#+end_src

*** PID Control

From Wikipedia: 

#+BEGIN_QUOTE
A PID controller calculates an 'error' value as the difference between
a measured [Input] and a desired setpoint. The controller attempts to
minimize the error by adjusting [an Output].
#+END_QUOTE

From [[http://playground.arduino.cc/Code/PIDLibrary][PIDLibrary]],

#+BEGIN_QUOTE
So, you tell the PID what to measure (the "Input",) Where you want
that measurement to be (the "Setpoint",) and the variable to adjust
that can make that happen (the "Output".) The PID then adjusts the
output trying to make the input equal the setpoint.
#+END_QUOTE

#+begin_src clojure :tangle no
  (def controller (pid-controller :kp 0.5
                                  :ki 0
                                  :kd 0
                                  :set-point 5 ;; or symbol to a fn
                                  ;;in min - in max - out min - out max
                                  :bounds [0 10 0 10]
                                  :continuous false))

  (println "Control" (controller 0))
#+end_src

Ported from,

#+begin_src java
  /*
   ,* *********************************************************
   ,* Copyright (c) 2009 - 2015, DHBW Mannheim - Tigers Mannheim
   ,* Project: TIGERS - Sumatra
   ,* Date: Jun 10, 2015
   ,* Author(s): Nicolai Ommer <nicolai.ommer@gmail.com>
   ,* *********************************************************
   ,*/

  /**
   ,* @author Nicolai Ommer <nicolai.ommer@gmail.com>
   */
#+end_src

#+name: runtime-clojure-pid-controller
#+begin_src clojure :tangle no
  (defobject pid_controller "ferret/obj/pid_controller_o.h")
#+end_src

#+begin_src c++ :mkdirp yes :tangle src/src/ferret/obj/pid_controller_o.h
  template <typename T>
  class pid_controller : public object_t {
    T p;
    T i;
    T d;
    T maximum_output;
    T minimum_output;
    T maximum_input;
    T minimum_input;
    bool continuous;
    T prev_error;
    T total_error;
    T setpoint;
    T error;
    T result;
    T input;
  public:

    pid_controller(var kp, var ki, var kd,
                   var inMin, var inMax, var outMin, var outMax,
                   var cont){
      p = number::to<T>(kp);
      i = number::to<T>(ki);
      d = number::to<T>(kd);
      maximum_output = number::to<T>(outMax);
      minimum_output = number::to<T>(outMin);
      maximum_input = number::to<T>(inMax);
      minimum_input = number::to<T>(inMin);;
      continuous = cont.cast<boolean>()->container();
      prev_error = 0;
      total_error = 0;
      setpoint = 0;
      error = 0;
      result = 0;
      input = 0;
    }

    size_t type() const { return runtime::type::pid_controller; }

    var equals(var o){
      return obj<boolean>(this == o.cast<pid_controller>());
    }

  #if !defined(FERRET_DISABLE_STD_OUT)
    var stream_console() const {
      runtime::print("pid_controller"); return nil();
    }
  #endif


    var update(var in){
      input = number::to<T>(in);

      // Calculate the error signal
      error = setpoint - input;

      // If continuous is set to true allow wrap around
      if (continuous) {
        if (runtime::abs(error) > ((maximum_input - minimum_input) / 2)) {
          if (error > 0) {
            error = (error - maximum_input) + minimum_input;
          } else {
            error = (error + maximum_input) - minimum_input;
          }
        }
      }
                                
      /*
       ,* Integrate the errors as long as the upcoming integrator does
       ,* not exceed the minimum and maximum output thresholds
       ,*/
      if ((((total_error + error) * i) < maximum_output) &&
          (((total_error + error) * i) > minimum_output)) {
        total_error += error;
      }
                                
      // Perform the primary PID calculation
      result = ((p * error) + (i * total_error) + (d * (error - prev_error)));
                                
      // Set the current error to the previous error for the next cycle
      prev_error = error;
                                
      // Make sure the final result is within bounds
      if (result > maximum_output) {
        result = maximum_output;
      } else if (result < minimum_output) {
        result = minimum_output;
      }

      return obj<number>(result);
    }
    void set_setpoint(var p){
      T sp = number::to<T>(p);
      if (maximum_input > minimum_input) {
        if (sp > maximum_input) {
          setpoint = maximum_input;
        } else if (sp < minimum_input) {
          setpoint = minimum_input;
        } else {
          setpoint = sp;
        }
      } else {
        setpoint = sp;
      }
    }
    void reset(){
      prev_error = 0;
      total_error = 0;
      result = 0;
    }
  };
#+end_src

#+name: runtime-clojure-pid-controller
#+begin_src clojure :tangle no
  (defn pid-controller-create [kp ki kd in-min in-max out-min out-max continuous]
    "__result = obj<pid_controller<real_t>>(kp, ki, kd, 
                                           in_min, in_max, out_min, out_max, 
                                           continuous);")

  (defn pid-controller-set-point [controller sp]
    "controller.cast<pid_controller<real_t>>()->set_setpoint(sp);")

  (defn pid-controller-update [controller input]
    "__result = controller.cast<pid_controller<real_t>>()->update(input)")

  (defmacro pid-controller [& options]
    (let [defaults {:kp 0 :ki 0 :kd 0 :set-point 0 :bounds [-1 1 -1 1] :continuous false}
          options (merge defaults (apply hash-map options))
          {:keys [container kp ki kd set-point bounds continuous]} options
          [in-min in-max out-min out-max] bounds]
      (if (symbol? set-point)
        `(~'let [pid# (~'pid-controller-create
                       ~kp ~ki ~kd ~in-min ~in-max ~out-min ~out-max ~continuous)]
          (~'pid-controller-set-point pid# (~set-point))
          (~'fn [input#]
           (~'pid-controller-set-point pid# (~set-point))
           (~'pid-controller-update pid# input#)))
        `(~'let [pid# (~'pid-controller-create
                       ~kp ~ki ~kd ~in-min ~in-max ~out-min ~out-max ~continuous)]
          (~'pid-controller-set-point pid# ~set-point)
          (~'fn [input#]
           (~'pid-controller-update pid# input#))))))
#+end_src

*** Moving Average Filter

A First order IIR filter (exponentially decaying moving average
filter) to approximate a K sample first order IIR filter to
approximate a K sample moving average. This filter approximates a
moving average of the last K samples by setting the value of alpha to
1/K.

#+name: runtime-clojure-filter
#+begin_src clojure :tangle no
  (defn moving-average-filter [alpha average data]
    (+ (* alpha data)
       (* (- 1.0 alpha) average)))
#+end_src

 - http://electronics.stackexchange.com/a/34426
 - http://stackoverflow.com/a/3761318

** GPIO
*** pin-mode

Configures the specified pin to behave either as an input or an
output.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defmacro pin-mode [pin mode]
    (let [pin (if (number? pin)
                pin
                (str "number::to<number_t>(" (symbol-conversion pin) ")"))
          mode (-> mode name .toUpperCase)]
      `(~'cxx ~(str "::pinMode(" pin ", " mode ");"))))
#+end_src

*** digital-write

Write a HIGH or a LOW value to a digital pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative digital-write [pin val]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::digitalWrite(number::to<number_t>(pin), number::to<number_t>(val));"))
#+end_src

*** digital-read

Reads the value from a specified digital pin, either HIGH or LOW.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative digital-read [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<number>(::digitalRead(number::to<number_t>(pin)));"))
#+end_src

*** analog-write

Writes an analog value (PWM wave) to a pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-write [pin val]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::analogWrite(number::to<number_t>(pin),number::to<number_t>(val));"))
#+end_src

*** analog-read

Reads the value from the specified analog pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-read [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "__result = obj<number>((number_t)::analogRead(number::to<number_t>(pin)));"))
#+end_src

*** analog-write-resolution

Sets the resolution of the *analog-write*

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-write-resolution [bit]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::analogWriteResolution(number::to<number_t>(bit));"))
#+end_src

*** analog-read-resolution

Sets the size (in bits) of the value returned by *analog-read*.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative analog-read-resolution [bit]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::analogReadResolution(number::to<number_t>(bit));"))
#+end_src

*** tone/noTone

Generates a square wave of the specified frequency (and 50% duty
cycle) on a pin.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative tone [pin freq]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::tone(number::to<number_t>(pin), number::to<number_t>(freq));"))
#+end_src

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defnative no-tone [pin]
    (on "defined FERRET_HARDWARE_ARDUINO"
        "::noTone(number::to<number_t>(pin));"))
#+end_src

*** attach-interrupt

Registers an interrupt function for the given pin and mode. See
[[https://www.arduino.cc/en/Reference/AttachInterrupt][attachInterrupt()]] for more information.

#+begin_src clojure
  (def input-pin  3)
  (def debug-pin 13)

  (pin-mode debug-pin :output)

  (defn control-light []
    (->> (digital-read  input-pin)
         (digital-write debug-pin)))

  (attach-interrupt control-light input-pin :change)

  (forever
   (sleep 100))
#+end_src

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defmacro attach-interrupt [callback pin mode]
    (let [pin (if (number? pin)
                pin
                (str "number::to<number_t>(" (symbol-conversion pin) ")"))
          mode (-> mode name .toUpperCase)
          cb-sym (gensym)]
      `(~'do
        (~'def ~cb-sym ~callback)
        (~'cxx
         ~(str "::pinMode(" pin " , INPUT_PULLUP);\n"
               "auto int_pin = digitalPinToInterrupt(" pin ");\n"
               "::attachInterrupt(int_pin, [](){ run(" cb-sym ");}, " mode ");")))))
#+end_src

*** no-interrupt

Executes critical section with interrupts disabled.

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defmacro no-interrupt [& body]
    `(~'no-interrupt-aux  (~'fn [] ~@body)))

  (defn no-interrupt-aux [f]
    "noInterrupts();
     __result = run(f);
     interrupts();")
#+end_src

*** detach-interrupt

Turns off the given interrupt.

#+BEGIN_EXAMPLE
  (detach-interrupt input-pin)
#+END_EXAMPLE

#+name: runtime-clojure-gpio
#+begin_src clojure :tangle no
  (defmacro detach-interrupt [pin]
    (let [pin (if (number? pin)
                pin
                (str "number::to<number_t>(" (symbol-conversion pin) ")"))]
      `(~'cxx
        ~(str "::detachInterrupt(digitalPinToInterrupt(" pin "));"))))
#+end_src

** Testing
*** assert

Evaluates expr and aborts if it does not evaluate to logical true.

#+name: runtime-clojure-testing
#+begin_src clojure :tangle no
  (defn assert-aux [f msg]
    (when (not (f))
      (println "Assertion Failed =>" msg)
      (system-abort)))

  (defn assert-aux-callback [f callback]
    (when (not (f)) (callback)))

  (defmacro assert
    ([exp]
     `(~'assert-aux (~'fn [] ~exp) ~(-> exp pr-str (clojure.string/escape {\\ "\\\\"}))))
    ([exp callback]
     `(~'assert-aux-callback (~'fn [] ~exp) (~'fn [] ~callback))))
#+end_src

*** deftest

Support for Clojure style unit testing. See [[Unit Testing]] for more
information.

#+name: runtime-clojure-testing
#+begin_src clojure :tangle no
  (defn is-aux-expect [ex-fb form-fn form-str]
    (let [expect (ex-fb)
          got  (form-fn)]
      (when (not=  expect got)
        (println "fail in" form-str "\n expected" expect "\n      got" got))))

  (defn is-aux [f msg]
    (when (not (f))
      (println "fail" msg)))

  (defmacro is [form]
    (let [check-op (first form)
          form-str (-> form pr-str (clojure.string/escape {\\ "\\\\"}))]

      (cond (= check-op '=)
            (let [[_ expected form] form]
              `(~'is-aux-expect (~'fn [] ~expected) (~'fn [] ~form) ~form-str))
            
            :default `(~'is-aux (~'fn [] ~form) ~form-str))))

  (defmacro deftest [name & exprs]
    (defonce fir-unit-tests (atom []))
    (swap! fir-unit-tests conj name)
    `(def ~name (~'fn [] ~@exprs)))

  (defmacro run-all-tests []
    (if (bound? #'fir-unit-tests)
      `(~'do ~@(map #(list %) @fir-unit-tests))
      `(~'do )))
#+end_src

** Native
*** defnative

Allows a function to be defined for multiple platforms see [[Accessing C,C++ Libraries]] for
examples.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro defnative [name args & form]
    (let [includes (->> (filter #(seq? (nth % 2)) form)
                        (map #(cons (nth % 1) (apply list (nth % 2))))
                        (map (fn [form]
                               (let [[guard & headers] form]
                                 (str "\n#if " guard " \n"
                                      (apply str (map #(str "#include \"" % "\"\n") headers))
                                      "#endif\n"))))
                        (map #(list 'native-declare %)))
          body (->> (map #(vector (second %) (last %)) form)
                    (map #(str "\n#if " (first %) " \n"
                               (second %)
                               "\n#endif\n"))
                    (apply str))
          pre-ample (->> (map #(vector (second %) (drop-last (drop 3 %))) form)
                         (remove #(empty? (second %)))
                         (map #(str "\n#if " (first %) " \n"
                                    (apply str (map (fn [line] (str line "\n")) (second %)))
                                    "\n#endif\n"))
                         (map #(list 'native-declare %)))]
      `(~'def ~name (~'fn* ~args ~@includes ~@pre-ample  ~body))))
#+end_src

*** pr-object-sizes

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defn pr-object-sizes []
    (println "Object Sizes")
    (println "\tvar:\t\t\t" (cxx "__result = obj<number>((number_t)sizeof(var));"))
    (println "\tobject:\t\t\t" (cxx "__result = obj<number>((number_t)sizeof(object_t));"))
    (println "\tpointer:\t\t" (cxx "__result = obj<number>((number_t)sizeof(pointer));"))
    (println "\tnumber:\t\t\t" (cxx "__result = obj<number>((number_t)sizeof(number));"))
    (println "\tkeyword:\t\t" (cxx "__result = obj<number>((number_t)sizeof(keyword));"))
    (println "\tsequence:\t\t" (cxx "__result = obj<number>((number_t)sizeof(sequence));"))
    (println "\tlazy_sequence:\t\t" (cxx "__result = obj<number>((number_t)sizeof(lazy_sequence));"))
    (println "\tstring:\t\t\t" (cxx "__result = obj<number>((number_t)sizeof(string));"))
    (println "\tboolean:\t\t" (cxx "__result = obj<number>((number_t)sizeof(boolean));"))
    (println "\tlambda_i:\t\t\t" (cxx "__result = obj<number>((number_t)sizeof(lambda_i));"))
    (println "\tatom:\t\t\t" (cxx "__result = obj<number>((number_t)sizeof(atomic_reference));"))
    (println "\tpid_controller<real_t>:\t"
             (cxx "__result = obj<number>((number_t)sizeof(pid_controller<real_t>));"))
    (println "\tpid_controller<number_t>:\t"
             (cxx "__result = obj<number>((number_t)sizeof(pid_controller<number_t>));")))
#+end_src

*** memory-pool-free-space

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative memory-pool-free-space []
    (on "defined FERRET_MEMORY_POOL_SIZE"
        "size_t acc = 0;
         for(size_t i = 0; i < FERRET_MEMORY_POOL_PAGE_COUNT; i++)
           if(mem::allocator::program_memory.used.get(i) == false)
             acc++;
         __result = obj<number>((acc*sizeof(FERRET_MEMORY_POOL_PAGE_TYPE)));"))
#+end_src

*** lock-memory

Wraps mlockall - locks the address space of process.

#+name: runtime-clojure-misc
#+begin_src clojure :tangle no
  (defnative lock-memory []
    (on "defined FERRET_STD_LIB"
        ("sys/mman.h")
        "mlockall(MCL_CURRENT | MCL_FUTURE);"))
#+end_src

** Compiler
*** configure-runtime!

Configure Ferret Runtime options. See table in [[Configuration]] section.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro configure-runtime! [& body]
    `(~'native-define ~(->> (partition 2 body)
                            (map #(str "#define " (first %) " " (second %) "\n"))
                            (list))))
#+end_src

*** configure-ferret!

Embed compilations options.

#+name: runtime-clojure-defn
#+begin_src clojure :tangle no
  (defmacro configure-ferret! [& body]
    `(~'native-define ~(str "// build-conf-begin\n"
                            "//" (str (apply hash-map body)) "\n"
                            "// build-conf-end\n")))
#+end_src

* Testing
  :PROPERTIES:
  :noweb-ref: ferret-unit-tests
  :END:
** Unit Testing
  :PROPERTIES:
  :noweb-ref: file-no-tangle
  :END:

The reliability and robustness of Ferret is achieved in part by
thorough and careful testing. Ferret lisp has built-in support for
unit testing using an api that mimics [[https://clojure.github.io/clojure/clojure.test-api.html][clojure.test]] api.

The core of the library is the "is" macro, which lets you make
assertions of any arbitrary expression, which will print a message if
the assertion fails.

#+begin_src clojure
  (is (= 42 (meaning-of-life)))
#+end_src

These assertions can be grouped using a [[deftest]] form which defines a
test function with no arguments. Tests can be defined separately from
the rest of the code, even in a different module.

#+begin_src clojure :tangle no
  (defn meaning-of-life [] 42)

  (deftest life-test
    (is (= 42 (meaning-of-life))))

  (run-all-tests)
#+end_src

This creates functions named /life-test/, which can be called like any
other function.  Therefore, tests can be grouped and composed, in a
style similar to the test framework in Peter Seibel's "Practical
Common Lisp" Finally all tests in the current program can be run using
the [[deftest][run-all-tests]].

** Continuous Integration

Each new commit is tested against a set of assertions.  Tests are run
by the CI system for the following compilers, 

 - GCC 5
 - Clang 3.4

Most tests are done using the built in unit testing api, but certain
tests, those that target the workings of the compiler are easier to do
using /clojure.test/ framework by compiling forms using Ferret then
comparing the their runtime output to their expected output. All
generated code is statically checked using /cppcheck/ and tested
against memory leaks.

Build options,

 - -std=c++11
 - -pedantic
 - -Werror
 - -Wall
 - -Wextra
 - -Woverloaded-virtual
 - -Wuninitialized
 - -Winit-self
 - -fsanitize=leak
 - -fsanitize=undefined

Static code analysis (cppcheck) options,

 - --std=c++11
 - --template=gcc
 - --enable=all
 - --error-exitcode=1

** Compiler
  :PROPERTIES:
  :noweb-ref: clojure-unit-tests
  :END:

#+begin_src clojure :tangle no
  (deftest compiler-core
    (let [program (compile '((defn one-plus-one []
                               (+ 1 1))

                             (while true
                               (+ 1 1))) {})]
      ;;while shoud use one-plus-one in its body
      ;;check lambda-already-defined?
      (is (= 2 (count (select-form program (fn [f] (= 'one_plus_one f))))))
      ;;test shake-concat
      (is (= '((defn c [] 1)
               (defn b [] (c))
               (defn a [] (b))
               (a))
             (shake-concat '((defn no-call-a [])
                             (defnative no-call-b [] (on "" ""))
                             (defn c [] 1)
                             (defn b [] (c))
                             (defn a [] (b)))
                           '((a)))))
      (is (= '((defn y [])
               (let [a 1]
                 (defn b []))
               (println (b) (y)))
             (shake-concat '((defn x [] )
                             (defn y [] )
                             (let [a 1]
                               (defn b [] )
                               (defn c [] a)))
                           '((println (b) (y))))))
      (is (= '((defn p-create []) (defn p-update []))
             (take 2 (shake-concat '((defn p-create [])
                                     (defn p-update [])
                                     (defmacro pc [& options]
                                       `(~'let [controller# (~'p-create)]
                                         (~'fn [input#] (~'p-update)))))
                                   '((pc))))))
      (is (= '(defn new-lazy-seq [f] )
             (first (shake-concat '((defn new-lazy-seq [f] )
                                    (defmacro lazy-seq [& body]
                                      `(~'new-lazy-seq (~'fn [] ~@body)))
                                    (defn range
                                      ([high]
                                       (range 0 high))
                                      ([low high]
                                       (if (< low high)
                                         (cons low (lazy-seq
                                                    (range (inc low) high)))))))
                                  '((range 10))))))))
#+end_src

** Core
*** Special Forms

#+begin_src clojure :tangle no
  (def make-adder
    (fn [n]
      (fn [x] (+ x n))))

  (def adder
    (make-adder 1))

  (def fibo
    (fn [n]
      (if (< n 2)
        1
        (+ (fibo (- n 1))
           (fibo (- n 2))))))

  (native-declare "ferret::number_t i = 0;")

  (defn inc-int []
    "__result =  obj<number>(i++);")

  (def nested-multi-call (do (fn
                               ([]    0)
                               ([x]   1)
                               ([x y] 2))))

  (deftest special-forms-test
    (is (= 1                @(atom 1)))
    (is (= 3                (#(+ 1 2))))
    (is (= 11               ((fn [n] (+ n 1)) 10)))
    (is (= 3               (((fn [n] (fn [n] n)) 3) 3)))
    (let [args (list "1" "2")]
      (is (= args (rest *command-line-args*))))

    (let [a 1]
      (is (= 1 a)))

    (let [a 1
          a 3]
      (is (= 3 a)))
    
    (let [a 1
          b 2]
      (is (= 3 (+ a b))))

    (let [a 1
          b 2
          c 3]
      (is (= 6 (+ a b c))))

    (let [a 1
          b 2]
      (let []
        (is (= 3 (+ a b)))))

    (is (= 0 (nested-multi-call)))
    (is (= 1 (nested-multi-call 1)))
    (is (= 2 (nested-multi-call 1 2)))
    
    (is (= 10 (adder 9)))
    (is (= 89 (fibo 10)))
    (is (= 0 (inc-int)))
    (is (= 1 (inc-int))))
#+end_src

*** Destructuring

#+begin_src clojure :tangle no
  (defn destructure-test-1 [[a b c]]
    (list a b c))

  (defn destructure-test-2 [[a [b] c]]
    b)

  (defn destructure-test-3 [[a [_ b] c]]
    b)

  (defn destructure-test-4 [& a]
    a)

  (defn destructure-test-5 []
    (let [[a b c] (list 1 2 3)]
      (list a b c)))

  (defn destructure-test-6 []
    (let [[_ _ a] (list 1 2 3)]
      a))

  (deftest destructuring-test
    (is (= 3                   (count (destructure-test-1 (list 1 2 3)))))
    (is (= 2                   (destructure-test-2 (list 1 (list 2) 3))))
    (is (= 3                   (destructure-test-3 (list 1 (list 2 3) 3))))
    (is (= (list (list 1 2 3)) (destructure-test-4 (list 1 2 3))))

    (let [a (list 1 2 3 4)
          [b c & r] a]

      (is (= 1          b))
      (is (= 2          c))
      (is (= (list 3 4) r)))

    (let [a 1 b 2
          [c & r] (list 4 5)]
      
      (is (= 1 a))
      (is (= 2 b))
      (is (= 4 c))
      (is (= (list 5) r)))

    (let [[a & r] (list 1 2 3)
          rr (rest r)]
      (is (= (list 3) rr)))
    
    (is (= (list 1 2 3) (destructure-test-5)))
    (is (= 3            (destructure-test-6)))


    (let [[_ _ a] (list 1 2 3)
          [_ b] (list 4 5 6)]
      (is (= 3 a))
      (is (= 5 b)))

    (let [a (list 1 2 3)
          [b c d e f g] a]
      (is (= 1   b))
      (is (= 2   c))
      (is (= 3   d))
      (is (= nil e))
      (is (= nil f))
      (is (= nil g))))
#+end_src

*** Conditionals

#+begin_src clojure
  (deftest conditionals-test
    (is (= 2   (if 1 2)))
    (is (= 1   (if (zero? 0) 1 -1)))
    (is (= -1  (if (zero? 1) 1 -1)))
    (is (= 2   (when true 2)))
    (is (= 2   (if nil 1 2)))
    (is (= nil (if-let [a nil] a)))
    (is (= 5   (if-let [a 5] a)))
    (is (= 2   (if-let [[_ a] (list 1 2)] a)))
    (is (= nil (when-let [a nil] a)))
    (is (= 5   (when-let [a 5] a)))
    (is (= 2   (when-let [[_ a] (list 1 2)] a)))

    (is (= 1     (when (< 2 3) 1)))
    (is (= true  (let [a 1] (and (> a 0) (< a 10)))))
    (is (= false (let [a 11] (and (> a 0) (< a 10)))))
    (is (= true  (and true true)))
    (is (= false (and true false)))
    (is (= true  (or true false)))
    (is (= false (or false false))))
#+end_src

*** Logical Operators

#+begin_src clojure
  (defn pos-neg-or-zero [n]
    (cond
      (< n 0) -1
      (> n 0)  1
      :else    0))

  (deftest logical-operators-test
    (is (= true  (< 2)))
    (is (= true  (< 2 3 4 5)))
    (is (= true  (> 2)))
    (is (= false (> 2 3 4 5)))
    (is (= true  (> 6 5 4 3)))
    (is (= true  (>= 2)))
    (is (= true  (>= 5 4 3 2 2 2)))
    (is (= false (>= 5 1 3 2 2 2)))
    (is (= true  (<= 2)))
    (is (= true  (<= 2 2 3 4 5)))
    (is (= false (<= 2 2 1 3 4)))
    (is (= true  (= 2)))
    (is (= false (= 2 3)))
    (is (= true  (= 2 2 2 2)))
    (is (= true  (= 2 2.0 2)))
    (is (= false (= 2 2 2 2 3 5)))
    (is (= true  (= (list 1 2) (list 1 2))))
    (is (= false (= (list 1 2) (list 1 3))))
    (is (= true  (= true true)))
    (is (= false (not (= true true))))
    (is (= false (not 1)))

    (let [a (fn [x] (+ 1 x))
          b (fn [x] (inc x))]
      (is (= true  (= a a)))
      (is (= false (= a b)))
      (is (= true  (= nil ((fn [] )))))
      (is (= true  (= nil ((fn [x y] ) 1 2)))))

    (is (= -1  (pos-neg-or-zero -5)))
    (is (=  1  (pos-neg-or-zero  5)))
    (is (=  0  (pos-neg-or-zero  0)))

    (is (= true  (true? true)))
    (is (= false (true? false)))
    (is (= false (false? true)))
    (is (= true  (false? false)))
    (is (= false (= nil 1)))
    (is (= false (= 1 nil)))
    (is (= true  (= nil nil)))

    (is (= true  (pos? 1)))
    (is (= true  (pos? 0.2)))
    (is (= false (pos? 0)))
    (is (= false (neg? 1)))
    (is (= true  (neg? -1)))
    (is (= true  (zero? 0)))
    (is (= false (zero? 10)))
    (is (= true  (zero? (- 1 1))))
    (is (= true  (zero? (- 1.2 1.2))))
    (is (= true  (zero? (+ 1.2 -1.2)))))
#+end_src

*** Math

#+begin_src clojure :tangle no
  (deftest math-test
    (is (= 0.6 (+ 0.3 0.3)))
    (is (= 0   (+ )))
    (is (= 1   (+ 1)))
    (is (= 10  (+ 1 2 3 4)))
    (is (= 10  (+ 1 2.0 3 4)))
    (is (= -1  (- 1)))
    (is (= 0   (- 4 2 2)))
    (is (= 0   (- 4 2 2.0)))
    (is (= 1   (* )))
    (is (= 8   (* 2 2 2)))
    (is (= 8   (* 2.0 2 2)))
    (is (= 1   (/ 1)))
    (is (= 0.5 (/ 2)))
    (is (= 1   (/ 4 2 2)))
    (is (= 1   (/ 4 2 2.0)))
    
    (is (= 1         (floor 1.1)))
    (is (= 1         (floor 1.5)))
    (is (= 1         (floor 1.9)))
    (is (= 0         (mod 2 2)))
    (is (= 0         (mod 4 2)))
    (is (= 1         (mod 5 2)))
    (is (= 1         (mod 8 7)))
    (is (= 4.98588   (mod -1.2973 (* 2 3.14159265358979323846))))
    (is (= 1         (min 1)))
    (is (= 1         (min 2 1)))
    (is (= 1         (min 3 5 7 1)))
    (is (= 1         (max 1)))
    (is (= 2         (max 2 1)))
    (is (= 7         (max 3 5 7 1)))
    
    (is (= 100 (scale 10 0 10 0 100)))
    (is (= 50  (scale 5 0 10 0 100)))
    (is (= 0   (scale 0 0 10 0 100)))
    (is (= 5   (clamp 10 0 5)))
    (is (= 10  (clamp 10 0 20)))
    (is (= 0   (clamp 10 -10 0)))
    (is (= -10 (clamp -100 -10 0)))

    (is (= 0     (number-combine (number-split 0))))
    (is (= 512   (number-combine (number-split 512))))
    (is (= 1024  (number-combine (number-split 1024))))
    (is (= 2048  (number-combine (number-split 2048))))
    (is (= 32000 (number-combine (number-split 32000))))

    (is (= true (not (nil? (rand)))))
    (is (= true (not (nil? (rand 15)))))

    (is (= -5 (bit-not  4)))
    (is (= -1 (bit-not  0)))
    (is (= 7  (bit-or   4 3)))
    (is (= 1  (bit-or   0 1)))
    (is (= 0  (bit-and  4 3)))
    (is (= 0  (bit-and  0 1)))
    (is (= 0  (bit-xor  4 4)))
    (is (= 1  (bit-xor  1 0)))
    (is (= 8  (bit-shift-left 4 1)))
    (is (= 16 (bit-shift-left 4 2)))
    (is (= 2  (bit-shift-right 4 1)))
    (is (= 1  (bit-shift-right 4 2)))

    (is (= 32         (sqrt 1024)))
    (is (= 2          (sqrt 4)))
    (is (= 8          (pow 2 3)))
    (is (= 16         (pow 2 4)))
    (is (= 1          (cos 0)))
    (is (= -0.99999   (cos 3.145)))
    (is (= 0          (sin 0)))
    (is (= -0.00340   (sin 3.145)))
    (is (= 0.98279    (atan2 45 30)))
    (is (= 180.19522  (to-degrees 3.145)))
    (is (= 3.14159    (to-radians 180)))

    (is (= 2.30258    (log 10)))
    (is (= 2          (log10 100)))

    (let [a 1
          b 2]
      (+ 1 a)
      (+ b a)
      (is (= 1 a))
      (is (= 2 b))
      (* 2 a)
      (* b a)
      (is (= 1 a))
      (is (= 2 b))
      (/ 2 a)
      (/ b a)
      (is (= 1 a))
      (is (= 2 b))
      (- 2 a)
      (- b a)
      (is (= 1 a))
      (is (= 2 b))))
#+end_src

*** Control

#+begin_src clojure :tangle no
  (deftest pid-controller-test
    (let [controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 0
                                     :set-point 5
                                     :bounds [0 10 0 10]
                                     :continuous false)]

      (is (= 5 (controller 0)))
      (is (= 5 (controller 0))))

    (let [controller (pid-controller :kp 1
                                     :ki 1
                                     :kd 0
                                     :set-point 5
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 15 (controller 0)))
      (is (= 20 (controller 0)))
      (is (= 20 (controller 0))))

    (let [controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 1
                                     :set-point 5
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 5 (controller 0))))

    (let [sp-fn (fn [] 5)
          controller (pid-controller :kp 1
                                     :ki 0
                                     :kd 1
                                     :set-point sp-fn
                                     :bounds [0 10 0 20]
                                     :continuous false)]

      (is (= 10 (controller 0)))
      (is (= 5 (controller 0)))))

  (deftest state-machine-test
    (let [state (atom 0)
          machine (state-machine
                   (states
                    (off (swap! state inc) :off)
                    (on  (swap! state inc) :on))
                   (transitions
                    (off (fn [] true) on)
                    (on  (fn [] true) off)))]
      
      (is (= :off (machine)))
      (is (= :on  (machine)))
      
      (dotimes [_ 8]
        (machine))
      
      (is (= 10 (deref state))))

    (let [state (atom 0)
          machine (state-machine
                   (states
                    (a (swap! state inc))
                    (b (swap! state inc))
                    (c (swap! state inc))
                    (no-op (swap! state inc)))
                   (transitions
                    (a
                     (fn [] false) no-op
                     (fn [] true)  b)
                    (b
                     (fn [] true)  c)
                    (c
                     (fn [] false) no-op
                     (fn [] false) no-op
                     (fn [] true)  a
                     (fn [] false) no-op)))]
      (dotimes [_ 10]
        (machine))
      (is (= 10 (deref state))))

    (let [state (atom nil)
          machine (state-machine
                   (states
                    (a (swap! state conj 1))
                    (b (swap! state conj 2))
                    (c (swap! state conj 3))
                    (no-op ))
                   (transitions
                    (a
                     (fn [] true) b
                     (fn [] true) c
                     (fn [] true) no-op)
                    (b (fn [] true) no-op)
                    (c (fn [] true) no-op)
                    (no-op (fn [] true) no-op)))]
      (dotimes [_ 50]
        (machine))
      (is (= (list 2 1) (deref state))))

    (let [value (atom 0)
          machine (state-machine 
                   (states
                    (increment (swap! value inc))
                    (no-op ))
                   (transitions
                    (increment
                     (fn [] true) increment
                     (fn [] true) no-op)
                    (no-op
                     (fn [] true) no-op)))]
      (machine)
      (machine)
      (is (= 2 (deref value)))))
#+end_src

*** Threading

#+begin_src clojure :tangle no
  (deftest threading-test
    (let [state (atom nil)
          add-wait (fn [time item]
                     (fn []
                       (sleep time)
                       (swap! state conj item)))]
      (thread (add-wait 10 1))
      (thread (add-wait 20 2))
      (sleep 30)
      (is (= (list 2 1) (deref state)))))

  (deftest timing-test
    (let [now (millis)]
      (sleep 150)
      (is (>= (- (millis) now) 100)))
    (is (>= (time-fn (fn [] (sleep 150) (+ 1 1))) 100))
    (is (>= (benchmark (fn [] (sleep 20) (+ 1 1)) 10) 10)))

  (defn ping [] true)

  (deftest fn-throttler-test
    (let [throttled-ping (fn-throttler ping 1 :second :blocking)
          begin (millis)]
      (throttled-ping)
      (throttled-ping)
      (throttled-ping)
      (is (> (- (millis) begin) 2000))
      (is (throttled-ping)))


    (let [throttled-ping (fn-throttler ping 1 :second :non-blocking)
          begin (millis)]
      (throttled-ping)
      (throttled-ping)
      (throttled-ping)
      (is (nil? (throttled-ping)))
      (is (< (- (millis) begin) 1000))))
#+end_src

*** XOR Stream

#+begin_src clojure :tangle no
  (def xor-stream-state (atom nil))

  (defn xor-sample-read-stream [buf]
    (let [buffer (atom buf)]
      (list
       (fn []
         (let [f (first (deref buffer))]
           (swap! buffer rest)
           f))
       (fn []
         (count (deref buffer)))
       (fn [vals]
         (reset! xor-stream-state vals)))))

  (defn xor-sample-write-stream []
    (let [buffer (atom (list))]
      (list
       (fn [v]
         (swap! buffer conj v))
       (fn []
         (reverse (deref buffer))))))

  (deftest xor-stream-test
    (let [[writer get-buffer] (xor-sample-write-stream)
          encoder (xor-stream-encoder writer)
          data (list (list 1 2 3 4)
                     (list 5 6 7 8))]
      (doseq [d data] 
        (encoder d))

      (let [[read in-waiting handler] (xor-sample-read-stream (get-buffer))
            decoder (xor-stream-decoder read in-waiting handler)]
        (dotimes [i 4]
          (decoder))
        (is (= (list 1 2 3 4) @xor-stream-state))
        (dotimes [i 4]
          (decoder))
        (is (= (list 5 6 7 8) @xor-stream-state)))))
 #+end_src
 
*** Misc

 #+begin_src clojure :tangle no
   (deftest doto-test
     (let [st (atom )
           add (fn [s v]
                 (swap! s conj v))]
       (doto st
         (add 1)
         (add 2)
         (add 3))
       (is (= (list 3 2 1) @st))))
 #+end_src

*** FFI

 #+begin_src clojure :tangle no
   (deftest ffi-test
     (is (= true  ((fn [a b] "__result = obj<boolean>((a == b))") (list 1 2) (list 1 2))))
     (is (= false ((fn [a b] "__result = obj<boolean>((a != b))") (list 1 2) (list 1 2))))
     (is (= true  ((fn [a b] "__result = obj<boolean>((a != b))") (list 1 2) 1)))
     (is (= false ((fn [a b] "__result = obj<boolean>((a == b))") 1          (list 1 2))))



     (is (=  nil   (my-find (list 5 5) (list (list 1 2)
                                             (list 2 3)
                                             (list 4 5)))))
     (is (=  true  (my-find (list 1 2) (list (list 1 2)
                                             (list 2 3)
                                             (list 4 5)))))
     (is (=  true  (my-find (list 4 5) (list (list 1 2)
                                             (list 2 3)
                                             (list 4 5)))))
     
     (is (= (list 1 2 3) (my-sort > (list 1 3 2))))
     (is (= (list 3 2 1) (my-sort < (list 1 3 2)))))
 #+end_src

*** Module System
  :PROPERTIES:
  :noweb-ref: import-module-test
  :END:

Run import tests. 

#+begin_src clojure :tangle no
  (require '[modules.module-a :as mod-a]
           '[modules.module-b :as mod-b])

  (deftest module-test-load-as
    (is (= 10  (mod-a/helper-a)))
    (is (= 1   (mod-a/helper-b)))
    (is (= 10  ((mod-a/ten-fn))))
    (is (= 11  ((mod-b/eleven-fn))))
    (is (= 1   (mod-a/helper-c)))
    (is (= 42  (mod-b/macro-call))))

  (require 'modules.module-a
           'modules.module-b)

  (require '[modules.module-c :as mod-c]
           'modules.module-d)

  (deftest module-test-load
    (is (= 10  (modules.module-a/helper-a)))
    (is (= 1   (modules.module-a/helper-b)))
    (is (= 10  ((modules.module-a/ten-fn))))
    (is (= 11  ((modules.module-b/eleven-fn))))
    (is (= 1   (modules.module-a/helper-c)))
    (is (= 42  (modules.module-b/macro-call)))
    (is (= 25  (cxx " __result = obj<number>(dummy_native_fn());")))
    (is (= 2   (cxx "__result = obj<number>((number_t)std::sqrt(4));"))))

  (run-all-tests)
#+end_src

**** Dummy Modules
     :PROPERTIES:
     :noweb-ref: ferret-tests-modules-no-export
     :END:  

Create some dummy programs under /test/,

#+begin_src clojure :mkdirp yes :tangle src/test/import_module_empty_aux_a.clj
  (require '[modules.module-a :as mod-a])
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/import_module_empty_aux_b.clj
  (require '[modules.module-a :as mod-a])
  (require '[modules.module-b :as mod-b])
#+end_src 

Create some dummy libs under /test/modules/,

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-a.clj
  (configure-runtime! FERRET_PROGRAM_MAIN "ferret::program_no_exec()")

  (defn helper-a [] 10)

  (defmacro ten-fn [] `(~'fn [] 10))

  (defmacro helper-b []
    (reduce (fn [a b] (+ a b)) (list 1 2 3))
    1)

  (defn helper-c []
    (helper-b))

  (defn update-aux []
    )

  (def update-data
    (fn-throttler update-aux 1000 :second :blocking))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-b.clj
  (require '[modules.module-c :as mod-c])

  (defn helper-b []
    (mod-c/helper-c))

  (defn eleven-fn []
    (mod-c/eleven-fn))

  (defnative macro-aux []
    (on "defined FERRET_STD_LIB"
        "__result = obj<number>((number_t)42);"))

  (defmacro macro-call []
    `(~'do (~'macro-aux)))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-c.clj
  (native-header "cmath")

  (defn helper-c []
    (print "Module C"))

  (defmacro eleven-fn []
    `(~'fn [] 11))
#+end_src 

#+begin_src clojure :mkdirp yes :tangle src/test/modules/module-d.clj
  (native-declare "int dummy_native_fn(){ return 25; }")
#+end_src 

*** Testing
  :PROPERTIES:
  :noweb-ref: clojure-unit-tests
  :END:

#+begin_src clojure :tangle no
  (deftest testing-unit-test
    (is (= "" (exec-form '((assert (= 2 1) (print "fail"))) {:release true})))
    (compare-output "" (run-all-tests))
    (compare-output
     (str "fail in (= 2 3) \n"
          " expected 2.0000 \n"
          "      got 3.0000\n"
          "fail (not (some-true))\n"
          "fail in (= 5 (apply + (list 1 2 3))) \n"
          " expected 5.0000 \n"
          "      got 6.0000\n"
          "fail in (= 3 (some-fn)) \n"
          " expected 3.0000 \n" 
          "      got 2.0000\n")
     
     (defn some-true [] true)

     (deftest some-test
       (is (= 2 3))
       (is (= 2 2))
       (is (not (some-true)))
       (is (some-true)))

     (defn some-fn [] 2)

     (deftest some-other-test
       (is (= 5 (apply + (list 1 2 3))))
       (is (= 6 (apply + (list 1 2 3))))
       (is (= 3 (some-fn)))
       (is (= 2 (some-fn))))

     (run-all-tests)))
#+end_src

** Data Structures
*** Number

#+begin_src clojure
  (deftest number-test
    (is (= 0.5       1/2))
    (is (= 0.33333   1/3))
    (is (= 3501      0xDAD))
    (is (= 2748      0xABC)))
#+end_src

*** Sequence

#+begin_src clojure :tangle no
  (deftest sequence-test
    (is (= true  (= (list ) (list ))))
    (is (= 0     (count (list ))))
    (is (nil?    (first (rest (rest (list))))))
    (is (= false (= (list )       (list 1 2 3))))
    (is (= false (= (list )       (list nil))))
    (is (= false (= (list 1 2 3)  (list 1 2))))
    (is (= false (= (list 1 2)    (list 1 2 3))))
    (is (= true  (= (list 1 2 3)  (list 1 2 3))))
    (is (= false (= (list 1 2 3)  (list 1 2 4))))
    (is (= false (= (list 1 1 3)  (list 1 2 3))))

    (is (= (list )            (rest (list ))))
    (is (= (list 1)           (cons 1 nil)))
    (is (= (list nil)         (cons nil nil)))
    (is (= 1                  (first (list 1 2 3 4))))
    (is (= 2                  (second (list 1 2 3 4))))
    (is (= (list 2 3 4)       (rest (list 1 2 3 4))))
    (is (= (list 3 4)         (rest (rest (list 1 2 3 4)))))
    (is (= (list 3 3 4)       (cons 3 (rest (rest (list 1 2 3 4))))))
    (is (= 3                  (first (cons 3 (rest (rest (list 1 2 3 4)))))))
    (is (= 4                  (count (list 1 2 3 4))))
    (is (= (list 4 3 2 1 1 2) (conj (list 1 2) 1 2 3 4)))
    (is (= (list 4 3 2 1)     (conj nil 1 2 3 4)))
    (is (= 21                 (reduce + (list 1 2 3 4 5 6))))
    (is (= 21                 (apply + (list 1 2 3 4 5 6))))

    (is (= 1   (nth (list 1 2 3) 0)))
    (is (= 2   (nth (list 1 2 3) 1)))
    (is (= 3   (nth (list 1 2 3) 2)))
    (is (= nil (nth (list 1 2 3) 10)))
    (is (= nil (nth (list 1 2 3) -10)))

    (is (= (list 0 1 2 3 4 5 6 7 8 9)  (nthrest (range 10) 0)))
    (is (= (list )                     (nthrest (range 10) 20)))
    (is (= (list 5 6 7 8 9)            (nthrest (range 10) 5)))
    
    (is (= (list 1 2 3 4) (drop 0 (list 1 2 3 4))))
    (is (= (list 2 3 4)   (drop 1 (list 1 2 3 4))))
    (is (= (list 3 4)     (drop 2 (list 1 2 3 4))))
    (is (= (list )        (drop 4 (list 1 2 3 4))))
    (is (= (list )        (drop 5 (list 1 2 3 4))))

    (is (= (list 6 5 4 3 2 1) (reverse (list 1 2 3 4 5 6))))
    (is (= (list 6 5 4 3 2)   (reduce (fn [h v] (conj h (inc v))) (list) (list 1 2 3 4 5))))
    (is (= (list 4 3 2 1 0)   (reduce (fn [h v] (conj h (dec v))) (list) (list 1 2 3 4 5))))

    
    (is (= 1 (first (repeatedly 3 (fn [] 1)))))
    (is (= 3 (count (repeatedly 3 (fn [] 1)))))
    (is (= 2 (->> (repeatedly 3 (fn [] 1)) (map inc) first)))
    (is (= 2 (->> (repeatedly (fn [] 1)) (take 3) (map inc) reverse first)))
    
    (is (= 2 (count (filter true? (list true false true false)))))
    (is (= 2 (count (filter false? (list true false true false)))))
    (is (= 3 (count (filter false? (list true false true false false)))))
    (is (= 2 (count (filter (fn [x] (not (false? x))) (list true false true false false)))))

    (let [sum (cxx "var alist = runtime::list(obj<number>(1),obj<number>(2),obj<number>(3));
                    number_t sum = 0;
                    for(auto it : runtime::range(alist)){
                      sum += number::to<number_t>(it);
                    }
                    __result = obj<number>(sum);")]
      (is (= 6 sum))))
#+end_src

*** Lazy Sequence

#+begin_src clojure
  (defn lazy-countdown [n]
    (if (>= n 0)
      (cons n (lazy-seq (lazy-countdown (- n 1))))))

  (defn ints-from [n]
    (cons n (lazy-seq (ints-from (inc n)))))

  (defn fib-seq
    ([]
     (fib-seq 0 1))
    ([a b]
     (lazy-seq
      (cons b (fib-seq b (+ a b))))))

  (deftest lazy-seq-test
    (is (= false (= (range 10) (range 15))))
    (is (= false (= (range 15) (range 10))))
    (is (= true  (= (range 10) (range 10))))
    (is (= 10    (first (ints-from 10))))
    (is (= 11    (first (rest (ints-from 10)))))
    (is (= 12    (first (rest (rest (ints-from 10))))))
    (is (= 10    (first (lazy-countdown 10))))
    (is (= 9     (first (rest (lazy-countdown 10)))))
    (is (= 8     (first (rest (rest (lazy-countdown 10))))))
    (is (= 11    (count (lazy-countdown 10))))

    (is (= 2   (first (map inc (list 1 2 3)))))
    (is (= 0   (first (map dec (list 1 2 3)))))
    (is (= 4   (first (map (fn [x] (+ 3 x)) (list 1 2 3)))))
    (is (= 3   (count (map inc (list 1 2 3)))))
    (is (= 10  (apply + (range 5))))
    (is (= 5   (count (range 5))))
    (is (= 2   (first (take 2 (map inc (list 1 2 3))))))
    (is (= 3   (first (rest (take 2 (map inc (list 1 2 3)))))))
    (is (= 3   (count (take 20 (map inc (list 1 2 3))))))
    (is (= 1   (first (concat (list 1 2 3) (list 4 5 6)))))
    (is (= 4   (first (drop 3 (concat (list 1 2 3) (list 4 5 6))))))
    (is (= 21  (reduce + (concat (list 1 2 3) (list 4 5 6)))))

    (is (= (list -2 -1)          (take-while neg? (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2)    (take-while #(< % 3) (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2 3)  (take-while #(<= % 3) (list -2 -1 0 1 2 3))))
    (is (= (list -2 -1 0 1 2 3)  (take-while #(<= % 4) (list -2 -1 0 1 2 3))))
    
    (is (empty? (concat)))
    
    (= (list 1 1 2 3 5) (take 5 (fib-seq)))
    (= 12 (apply + (take 5 (fib-seq))))

    (is (= (list (list 0 1 2 3) (list 4 5 6 7))                              (partition 4 (range 10))))
    (is (= (list (list 0 1 2 3) (list 4 5 6 7))                              (partition 4 (range 8))))
    (is (= (list (list 0 1 2 3) (list 6 7 8 9) (list 12 13 14 15))           (partition 4 6 (range 20))))
    (is (= (list (list 0 1 2) (list 6 7 8) (list 12 13 14) (list 18 19 42))  (partition 3 6 (list 42) (range 20))))
    (is (= (list (list 0 1 2 3) (list 6 7 8 9) (list 12 13 14 15) (list 18 19 42 43)) (partition 4 6 (list 42 43 44 45) (range 20)))))
#+end_src

*** Lambda

#+begin_src clojure
  (deftest lambda-test
    (let [f1 (fn [])
          f2 (fn [])
          m-func (fn
                   ([a] 1)
                   ([a b] 2)
                   ([a b & c] 3)
                   ([a b [c d] & e] 4))]
      (is (= true  (= f1 f1)))
      (is (= false (= f1 f2)))
      (is (= true  (= f1 (do f1))))
      (is (= false (= f2 (do f1))))
      (is (= 1 (m-func 1)))
      (is (= 2 (m-func 1 2)))
      (is (= 3 (m-func 1 2 3)))
      (is (= 4 (m-func 1 2 (list 3 3) 4)))))
#+end_src

*** Pointer

#+begin_src clojure
  (deftest pointer-test
    (let [state (atom false)]
      (let [a-gc-fn (fn [p] (reset! state true))
            a-ptr (cxx "__result = obj<pointer>(nullptr);")
            a-heavy-ptr (new-heavy-pointer a-ptr a-gc-fn)
            b-ptr (cxx "__result = obj<pointer>(new int);")
            b-gc-fn (fn [p] "delete pointer::to_pointer<int>(p);")
            b-heavy-ptr (new-heavy-pointer b-ptr b-gc-fn)]
        (is (= true  (= a-ptr a-ptr)))
        (is (= false (= a-ptr b-ptr)))
        (is (= true  (= a-heavy-ptr a-heavy-ptr)))
        (is (= false (= a-heavy-ptr b-heavy-ptr)))
        (is (= false (= b-heavy-ptr a-heavy-ptr)))
        (is (= true  (= b-heavy-ptr b-heavy-ptr))))
      (is (= true (deref state)))))

  (deftest value-test
    (let [obj-42 (make-data 42)
          obj-24 (make-data 24)
          val-42 (get-data obj-42)
          val-24 (get-data obj-24)]
      (is (=    obj-42 obj-42))
      (is (not= obj-42 obj-24))
      (is (=    val-42 42))
      (is (=    val-24 24))))
#+end_src

*** Atom

#+begin_src clojure
  (deftest atom-test
    (let [a (atom nil)
          b (atom nil)]
      (is (= nil          (deref a)))
      (is (= 1            (do (reset! a 1) (deref a))))
      (is (= 2            (do (swap! a inc) (deref a))))
      (is (= (list 1 2 3) (do (reset! a (list 1 2 3)) (deref a))))
      (is (= 6            (do (swap! a (fn [l] (reduce + l))) (deref a))))
      (is (= true         (= a a)))
      (is (= false        (= a b)))
      (is (= false        (= a 3.14)))))
#+end_src

*** Keyword

#+begin_src clojure
  (deftest keyword-test
    (is (= true  (= :test :test)))
    (is (= false (= :test :other_test)))
    (let [ke (fn [k] "__result = obj<boolean>(k.equals(obj<keyword>(\":space\")))")]
      (is (= true (ke :space)))))
#+end_src

*** String

#+begin_src clojure
  (deftest string-test
    (let [s1 "Some String"
          s2 "Other String"
          s1-ret (fn [] "__result = obj<string>(\"Some String\");")
          s1-eq (fn [s] "__result = obj<boolean>((string::to<std::string>(s) == \"Some String\"))")]
      (is (= false (= s1 s2)))
      (is (= true  (= s1 s1)))
      (is (= false (= s1 3.14)))
      (is (= true  (= s1 (s1-ret))))
      (is (= true  (s1-eq s1)))
      (is (= 99 \c))
      (is (= \S (first s1)))))
#+end_src

*** Memory Pool
    :PROPERTIES:
    :noweb-ref: memory-pool-test
    :END:

#+begin_src clojure
  (native-define "#define FERRET_MEMORY_POOL_SIZE 4194304") ;; 4 MB
  (native-declare "void* ptr;")

  (native-declare "ferret::mem::allocator::memory_pool<size_t,14> tiny_pool;")
  (let [next-page (fn [idx]
                    "size_t i = number::to<size_t>(idx);
                          __result = obj<number>((number_t)tiny_pool.next_page(i))")
        malloc (fn [size]
                 "size_t s = number::to<size_t>(size);;
                       ptr = tiny_pool.allocate(sizeof(size_t) * s);
                       __result = obj<boolean>((ptr != nullptr));")
        free (fn [] "tiny_pool.free(ptr);")]
    
    (assert (= 0 (next-page 0)))
    (assert (malloc 2))
    (assert (= 3 (next-page 0)))
    (assert (malloc 4))
    (assert (= 8 (next-page 2)))
    (free)
    (assert (= 3 (next-page 2)))
    (assert (false? (malloc 40)))
    (assert (malloc 6))
    (assert (malloc 1))
    (assert (malloc 1))
    (assert (false? (malloc 10))))

  (native-declare "ferret::mem::allocator::memory_pool<size_t,256> even_pool;")
  (let [next-page (fn [idx]
                    "size_t i = (size_t)number::to<size_t>(idx);
                          __result = obj<number>((number_t)even_pool.next_page(i))")
        malloc (fn [size]
                 "size_t s = number::to<size_t>(size);
                       ptr = even_pool.allocate(sizeof(size_t) * s);
                       __result = obj<boolean>((ptr != nullptr));")
        free (fn [] "even_pool.free(ptr);")]
    
    (assert (= 0 (next-page 0)))
    (assert (malloc 255))
    (assert (= 256 (next-page 0)))
    (free)
    (assert (= 0 (next-page 0)))
    (assert (false? (malloc 256)))
    (assert (= 0 (next-page 0))))

  (native-declare "ferret::mem::allocator::memory_pool<size_t,255> odd_pool;")
  (let [next-page (fn [idx]
                    "size_t i = number::to<size_t>(idx);
                         __result = obj<number>((number_t)odd_pool.next_page(i))")
        malloc (fn [size]
                 "size_t s = number::to<size_t>(size);
                       ptr = odd_pool.allocate(sizeof(size_t) * s);
                       __result = obj<boolean>((ptr != nullptr));")
        free (fn [] "odd_pool.free(ptr);")]
    
    (assert (= 0 (next-page 0)))
    (assert (malloc 254))
    (assert (= 255 (next-page 0)))
    (free)
    (assert (= 0 (next-page 0)))
    (assert (false? (malloc 255)))
    (assert (= 0 (next-page 0))))
#+end_src

* Roadmap
** Compiler

  - *Shared Library* - Ability to be run as a shared lib.
    - Export functions to JNA (C API)
  - *Escape Analysis* - Escape known language structures. Certain
    forms generate =fn=s that never escape. These can be generated on
    the stack.
  - *Escape Analysis* for other types. Currently escape analysis is
    only used for functions.    
    - [[https://news.ycombinator.com/item?id=12158191][Static Analysis]]
  - *Readbility* - Add context to auto generated symbols in compiled
    code.
  * Check out Typed Racket
  - Since Ferret does whole-program compilation. Implement
    optimizations from Stalin Scheme compiler.
    - https://github.com/barak/stalin
    - https://news.ycombinator.com/item?id=8214343
    - https://justindomke.wordpress.com/2009/02/23/the-stalin-compiler/

** Data Structures

  - *Association Lists* as an alternative to maps. More suited to
    embedded systems. Quoted from Wikipedia, for quite small values of
    n it is more efficient in terms of time and space than more
    sophisticated strategies such as hash tables.
    - D-Lists - https://news.ycombinator.com/item?id=11575540
    - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentHashMap.java
    - https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/APersistentMap.java
  - *Implement Que*
  - *Fixed-point Arithmetic*
    Implement fixed point real number type for embedded systems
    without a FPU.
    - [[https://www.reddit.com/r/lisp/comments/51kkym/fixedpoint_arithmetic_in_picolisp/][Fixed-point Arithmetic in Picolisp]]
    - [[https://accu.org/index.php/journals/1717][Why Fixed Point Won't Cure Your Floating Point Blues]]
    - http://jet.ro/files/The_neglected_art_of_Fixed_Point_arithmetic_20060913.pdf
    - [[https://alikhuram.wordpress.com/2013/05/20/implementing-fixed-point-numbers-in-c/][Implementing Fixed-Point Numbers in C++]]
  - *Unbounded Precision Integers*
    - [[http://www.more-magic.net/posts/numeric-tower-part-2.html][CHICKEN's numeric tower: part 2]]
    - [[https://web.archive.org/web/20101208222557/http://www.mactech.com/articles/mactech/Vol.08/08.03/BigNums/index.html][Arbitrarily Large Bignums]]
    - From p.11: PICOBIT: A Compact Scheme System for Microcontrollers
     - Larger values are needed in some embedded applications.
       - 48 bit integers to store MAC addresses.
       - SHA family of cryptographic hashing functions, which need
         values up to 512 bits wide.
       - If an application keeps track of time at the microsecond level
         using a 32-bit value, a wraparound will occur every hour or
         so.
     - Unbounded precision integers are encoded in PICOBIT as linked
       lists of 16 bit values. At the end of each list is either the
       integer 0 or -1, to represent the sign. 0, -1 and other small
       integers have dedicated encodings and do not need to be
       represented as linked lists. The use of this “little-endian”
       representation simplifies the bignum algorithms in particular
       for numbers of different lengths.
     - On versions of PICOBIT which do not support unbounded precision
       integers (including PICOBIT Light), integers are limited to 24
       bits, and encoded directly in the object.

** Core

  - *Pre/Post conditions* for functions.
    - By default print error and abort. 
    - Let user define a callback function.
  - *Cleaner FFI* - Current FFI system is modeled after [[http://gambitscheme.org/wiki/index.php/Using_Gambit_with_External_Libraries][Gambit
    Scheme]]. 
    - With a set a macros can provide a DSL like [[https://github.com/tomhrr/dale][Dale]].
    - Cleans up /defobject/ macro.
  - *Multimethods*
  - *Co-Operative Multitasking* - For Embedded Systems.
    - https://forum.pjrc.com/threads/25628-Lightweight-Teensy3-x-Fibers-Library-%28C-%29-Available
    - https://github.com/ve3wwg/teensy3_fibers/blob/1ba0c1e79a423f097e12e6c4176b40cf9d4f44e4/fibers.cpp
  - *memory_pool* - Option for enabling allocation profiling.
  - *memory_pool* - Ability to run functions on different Memory Pools.
    - Improved data locality and safety.
    - Optionally disable reference counting to improve performance since
      whole pool can be garbage collected when done.
    - Stalin also does very good lifetime analysis to reduce the
      amount of garbage needing collection. i.e. it will compute good
      places in the stack to create a heap, then objects that are
      determined to be born and die within that sub-stack are
      allocated from that heap. When the stack unwinds past that
      point, the entire local heap can be released in one fell swoop.

** Issues

  - *Variadic Templates* - GCC evaluates arguments in reverse order.
    - [[http://stackoverflow.com/questions/14060264/order-of-evaluation-of-elements-in-list-initialization][Order of evaluation of elements in list-initialization]]
    - [[https://blogs.msdn.microsoft.com/vcblog/2016/02/11/compiler-improvements-in-vs-2015-update-2/][Compiler improvements in VS 2015 Update 2]]

** Hardware

  - RPi GPIO
    - http://elinux.org/RPi_Low-level_peripherals
    - http://elinux.org/RPi_GPIO_Code_Samples

** The Rearview
*** Core

  - *Numberic Tower* - Numeric tower is now based on Lua number type.
  - *Pluggable Numbers* - Ability to change the default number type at
    compile time.
  - *Memory* - Option to disable [[Reference Counting]]. Combined with
    =FERRET_ALLOCATE= any third party GC can be supported.
    - http://www.ravenbrook.com/project/mps
    - http://www.hboehm.info/gc/
    Implemented =FERRET_DISABLE_RC= option.
  - *pointer* - A pointer type to handle shared pointers.
    Implemented value object_t.
  - *Unit Testing*
    - https://www.cs.northwestern.edu/academics/courses/325/readings/lisp-unit.html
    - https://github.com/fukamachi/prove
    - http://tgutu.github.io/clunit/#clunit_2
    - [[https://github.com/aw/picolisp-unit][Unit Testing framework for PicoLisp]]
    - http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html
    - [[http://www.jera.com/techinfo/jtns/jtn002.html][JTN002 - MinUnit -- a minimal unit testing framework for C]]
  - *throttled-fn* - Blocking and non blocking versions.
  - *require* - Import native declarations and headers.
  - *Native Headers* - Make =native-headers= a special form.
  - *Memory Pool* - Allow Multiple Implementations.
    Allow user definable =FERRET_ALLOCATE= - =FERRET_FREE=
  - *string* - string constructor from std::string.
  - *require* - require module without alias.
  - *require* - Only having *require* forms and nothing else causes
    null pointer exception.
  - *require* - Should support requiring multiple libraries. Currently
    each library import requires a require form.
  - *assert* - Strip during release build.
    - *--release* - CLI option added.
  - *pointer* - Ability to call cleanup function before *GC*
  - *Debugging* - Add some debugging macros, native side.
  - *pid_controller* - Implement Unit Tests.
  - *Continuous Integration* - Setup Travis CI, automate testing and
    deployment.
  - Implement *Range-based for loop* for seekable containers.
  - *Benchmarking* - Add a benchmarking function.
  - *Memory Pool* - Functions report in bytes.
  - *sequence* - Remove size from object.
  - *memory_pool* - Enable Locking, make it thread safe.
    - Removed - Wasted to much memory.
  - *Lazy Sequence* - Should cache the result of *rest* and return it
    on subsequent calls.
  - *assert* - https://clojuredocs.org/clojure.core/assert

*** Libraries

  - JSON Encode/Decode
    - https://git.nakkaya.com/nakkaya/ferret-boost
  - HTTP & WebSocket Client
    - https://git.nakkaya.com/nakkaya/ferret-websocket

* Files                                                            :noexport:
** project.clj

#+begin_src clojure :mkdirp yes :tangle src/project.clj
  (defproject ferret "1.0.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [fast-zip "0.7.0"]
                   [org.clojure/tools.cli "0.3.3"]
                   [org.bituf/clj-stringtemplate "0.2"]
                   [org.clojars.amit/commons-io "1.4.0"]
                   [commons-lang "2.5"]
                   [watchtower "0.1.1"]
                   [org.clojure/tools.logging "0.2.3"]
                   [clojure-term-colors "0.1.0-SNAPSHOT"]]
    :repl-options {:host "0.0.0.0"
                   :port 7888
                   :init-ns ferret.core}

    :filespecs [{:type :bytes :path "build.info"
                 :bytes ~(:out (clojure.java.shell/sh
                                "git" "rev-parse" "--short" "HEAD"))}]
    
    :main ferret.core
    :aot [ferret.core]
    :jar-name "interim.jar"
    :uberjar-name "ferret.jar")
#+end_src 

** src/
*** ferret/core.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/src/ferret/core.clj
  (ns ferret.core
    (:refer-clojure :exclude [compile])
    (:gen-class)
    (:use [clojure.java.io])
    (:require [clojure.set :as set]
              [fast-zip.core :as zip]
              [clojure.walk :as walk]
              [clojure.pprint :as pprint]
              [clojure.tools.cli :refer [parse-opts]]
              [watchtower.core :as watcher]
              [clojure.term.colors :as color])
    (:use [ferret.template]
          [clojure.java.shell]
          [clojure.tools [logging :only [log warn info trace]]])
    (:import (org.apache.commons.io FileUtils)))

  (defn os-name []
    (let [os (-> (System/getProperty "os.name") .toLowerCase)]
      (cond (.contains os "win")      :windows
            (.contains os "mac")      :mac
            (or (.contains os "nix")
                (.contains os "nux")
                (.contains os "aix")) :unix
            (.contains os "sunos")    :solaris)))

  <<core-logging>>
  <<core-code-generation-misc>>
  <<core-compilation-form-fns>>
  <<core-compilation-unique-fn>>
  <<core-compilation-normalize>>
  <<core-compilation-expand-macros>>
  <<core-compilation-shake-concat>>
  <<core-compilation-escape-analysis>>
  <<core-compilation-escape-analysis-post>>
  <<core-compilation-embed-ferret-core>>
  <<core-compilation-embed-ferret-runtime>>
  <<core-compilation-closure-conversion>>
  <<core-compilation-symbol-conversion>>
  <<core-compilation-remove-assertions>>
  <<core-compilation-do-fn>>
  <<core-compilation-let-fn>>
  <<core-compilation-process>>
  <<core-code-generation-emit>>
  <<core-code-generation-emit-source-methods>>
  <<core-code-generation-emit-source>>
  <<core-code-compile-code>>
#+end_src 

*** ferret/template.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/template.clj
  (ns ferret.template
    (:import (java.io BufferedReader InputStreamReader)
             (org.antlr.stringtemplate StringTemplateGroup StringTemplate)))

  (defn read-from-url [f]
    (with-open [in (.getResourceAsStream (ClassLoader/getSystemClassLoader) f)
                rdr (BufferedReader. (InputStreamReader. in))]
      (apply str (interpose \newline (line-seq rdr)))))

  (defn indexed
    "Returns a lazy sequence of [index, item] pairs, where items come
    from 's' and indexes count up from zero.

    (indexed '(a b c d))  =>  ([0 a] [1 b] [2 c] [3 d])"
    [s]
    (map vector (iterate inc 0) s))

  (defn create-view "Return new view template - useful as mentioned here:
      http://hardlikesoftware.com/weblog/2006/12/12/using-json-with-stringtemplate/"
    ([]
     (StringTemplate.))
    ([^String template]
     (StringTemplate. template)))


  (defn stringify [any]
    (if (keyword? any)
      (name any)
      (str any)))


  (declare kv-to-sv)
  (declare scan-kv-to-sv)


  (defn each-kv-to-sv "If element is a collection type, do deep transformation"
    [each]
    (if (map? each)
      (kv-to-sv each)
      (if (or (vector? each) (list? each) (seq? each) (set? each))
        (scan-kv-to-sv each)
        each)))


  (defn scan-kv-to-sv
    "Scans a collection and turns any contained map within from kv to sv"
    [coll]
    (map each-kv-to-sv coll))


  (defn kv-to-sv
    "Transforms keyword-value map {:a 10 :b 20 :c 30}
       to string-value map {\"a\" 10 \"b\" 20 \"c\" 30}"
    [mp]
    (let [m (into {} mp)
          k (keys m)
          v (vals m)]
      (zipmap
       (map stringify k)
       (scan-kv-to-sv v))))

  (defn get-view-from-classpath "Return the view template from classpath"
    [^String view-name]
    (let [st-group (StringTemplateGroup. "default")]
      (.getInstanceOf st-group view-name)))


  (defn get-view-from-dir "Return the view template from specified directory"
    [^String view-name ^String root-dir]
    (let [st-group (StringTemplateGroup. "default" root-dir)]
      (.getInstanceOf st-group view-name)))


  (defn reset-view! "Reset view template with supplied content"
    [^StringTemplate view ^String template]
    (.setTemplate view template))


  (defn fill-view! "Fill view template with key/value pairs"
      ;;;
    ;; Fill template with key and value
    ([^StringTemplate template k v]
     (.setAttribute template (stringify k) (each-kv-to-sv v))
     template)
      ;;;
    ;; Fill template with key/value from map
    ([^StringTemplate template kv-map]
     (.setAttributes template (kv-to-sv kv-map))
     template))


  (defn render-view "Return rendered view for the template"
    [^StringTemplate template]
    (.toString template))

  <<code-templates>>
#+end_src 

*** ferret/runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/src/ferret/runtime.clj
  <<runtime-clojure-thread-macro>>
  <<runtime-clojure-fn-macro>>
  <<runtime-clojure-boolean-object>>
  <<runtime-clojure-pointer-object>>
  <<runtime-clojure-number-object>>
  <<runtime-clojure-seekable-interface>>
  <<runtime-clojure-lambda-interface>>
  <<runtime-clojure-keyword-object>>
  <<runtime-clojure-sequence-object>>
  <<runtime-clojure-heavy-pointer-object>>
  <<runtime-clojure-string-object>>
  <<runtime-clojure-atom-object>>
  <<runtime-clojure-defn>>
  <<runtime-clojure-looping>>
  <<runtime-clojure-first>>
  <<runtime-clojure-sequence>>
  <<runtime-clojure-logical-operators>>
  <<runtime-clojure-conditionals>>
  <<runtime-clojure-math>>
  <<runtime-clojure-sequence-lazy>>
  <<runtime-clojure-bit-operations>>
  <<runtime-clojure-console-io>>
  <<runtime-clojure-misc>>
  <<runtime-clojure-state-machine>>
  <<runtime-clojure-pid-controller>>
  <<runtime-clojure-filter>>
  <<runtime-clojure-gpio>>
  <<runtime-clojure-testing>>
#+end_src

*** ferret/runtime.h

#+begin_src c++ :mkdirp yes :noweb yes :tangle src/src/ferret/runtime.h
  // Detect Hardware
  namespace ferret{
    <<runtime-native-hardware-detect>>
  }

  <<runtime-native-hardware-includes>>

  // Number Configuration
  <<runtime-native-number-config-macros>>

  // Initialize Hardware
  namespace ferret{
    <<runtime-native-hardware-initialize>>
    <<runtime-native-program-header>>
  }

  // Locking Macros
  namespace ferret{
    <<runtime-native-locking-macros>>
  }

  // Object System Base
  namespace ferret{
    class var;
    <<runtime-native-memory-system-allocator>>
    <<runtime-native-memory-pool-allocator-implementation>>
    <<runtime-native-memory-pool-allocator>>
    <<runtime-native-reference-counting>>
    <<runtime-native-object>>
    <<runtime-native-var>>
    <<runtime-native-object-allocation>>
  }
#+end_src 

** test/
*** compiler.clj

#+begin_src clojure :noweb yes :mkdirp yes :tangle src/test/compiler.clj
  (ns compiler
    (:refer-clojure :exclude [compile])
    (:use [ferret.core] :reload)
    (:use [clojure.test]
          [clojure.java.shell]
          [clojure.tools [logging :only [log warn info]]]))

  (set-log-level! :info)

  (defn exec-check [& cmd]
    (let [ret (with-sh-dir "./" (apply sh cmd))]
      (if (not= 0 (:exit ret))
        (do (warn (str "exec-check failure" cmd))
            (warn (:err ret))
            (System/exit 1))
        (:out ret))))

  (defn static-check [f]
    (exec-check
     "cppcheck" "-q" "--std=c++11" "--template=gcc" "--enable=all" "--error-exitcode=1" f))


  (def cxx-opts-common ["-std=c++11" "-pedantic" "-Werror" "-Wall" "-Wextra"
                        "-Woverloaded-virtual" "-Wuninitialized" "-Winit-self"
                        "-pthread"])

  (def cxx-llvm-opts ["-fsanitize=leak" "-fsanitize=undefined"])

  (def cxx [["/usr/bin/g++"         cxx-opts-common]
            ["/usr/bin/clang++-3.4" (concat cxx-opts-common cxx-llvm-opts)]])

  (defn test-file-aux [f]
    (info (str "testing " f))
    (let [f-name (gensym)
          file (str f-name ".cpp")
          specs (-> ((build-specs f {}))
                    (assoc :output-path "./")
                    (assoc :base-name   f-name))]
      (compile->cpp (read-clojure-file f) specs)
      (static-check file)
      (let [output (reduce (fn[h [cxx flags]]
                             (if (.exists (clojure.java.io/as-file cxx))
                               (do (compile->binary
                                    (assoc specs
                                           :compiler cxx
                                           :compiler-options (concat flags ["-o" f-name])))
                                   (let [output (exec-check (str "./" f-name) "1" "2")]
                                     (when (not (empty? output))
                                       (println )
                                       (println output))
                                     (conj h output)))
                               h))
                           [] cxx)]
        (with-sh-dir "./"
          (sh "rm" "-f" file)
          (sh "rm" "-f" (str f-name)))
        (filter #(not (empty? %)) output))))

  (defn test-file [f]
    (binding [clojure.test/report
              (fn [ev]
                (inc-report-counter (-> ev :type))
                (when (= (-> ev :type) :fail)
                  (warn (str "test file failed => " f))))]
      (is (empty? (test-file-aux f)))))

  (deftest test-ferret
    (test-file "test/import_module_main.clj")
    (test-file "test/import_module_empty_aux_a.clj")
    (test-file "test/import_module_empty_aux_b.clj")
    (test-file "test/runtime.clj")
    (test-file "test/memory_pool.clj"))

  (defn exec-form [form & [opts]]
    (let [options (compile-options {:compiler-options cxx-opts-common})
          options (merge options opts)]
      (compile->cpp form options)
      (compile->binary options)
      (static-check "solution.cpp")
      (let [out (exec-check "./a.out" "1" "2")]
        (with-sh-dir "./"
          (sh "rm" "-rf" "a.out")
          (sh "rm" "-rf" "solution.cpp"))
        out)))

  (defn report-test-failure [event]
    (let [actual (with-out-str
                   (clojure.pprint/pprint (:actual event)))
          expected (with-out-str
                     (clojure.pprint/pprint (:expected event)))]
      (let [type (-> event :type)]
        (inc-report-counter type)
        (when (= type :fail)
          (warn (str "test failure" \newline \newline actual \newline expected))))))

  (defmacro compare-output [res & body]
    `(binding [clojure.test/report report-test-failure]
       (is (= ~res (exec-form (quote ~body))))))

  <<clojure-unit-tests>>
#+end_src 

*** runtime.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/runtime.clj
  <<value-test-helpers>>
  <<ffi-test-helper>>
  <<ferret-unit-tests>>

  (run-all-tests)
#+end_src

*** memory_pool.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/memory_pool.clj
  <<memory-pool-test>>
#+end_src

*** module_import.clj

#+begin_src clojure :mkdirp yes :noweb yes :tangle src/test/import_module_main.clj
  <<import-module-test>>
#+end_src

** resources/
*** bash_executable_stub.sh

#+begin_src sh :mkdirp yes :tangle src/resources/bash_executable_stub.sh :padline no
  #!/usr/bin/env sh
  MYSELF=`which "$0" 2>/dev/null`
  [ $? -gt 0 -a -f "$0" ] && MYSELF="./$0"
  java=java
  if test -n "$JAVA_HOME"; then
      java="$JAVA_HOME/bin/java"
  fi
  exec "$java" $java_args -jar $MYSELF "$@"
  exit 1 
#+end_src

*** platform_builds.sh

#+begin_src sh :mkdirp yes :tangle src/resources/platform_builds.sh :padline no
  wget http://ferret-lang.org/build-artifacts/packr.jar
  wget http://ferret-lang.org/build-artifacts/openjdk-1.7.0-u80-unofficial-macosx-x86_64-image.zip
  wget http://ferret-lang.org/build-artifacts/openjdk-1.7.0-u80-unofficial-linux-amd64-image.zip
  wget http://ferret-lang.org/build-artifacts/openjdk-1.7.0-u80-unofficial-windows-amd64-image.zip

  java -jar packr.jar \
       --platform windows64 \
       --jdk openjdk-1.7.0-u80-unofficial-windows-amd64-image.zip \
       --executable ferret \
       --classpath target/ferret.jar \
       --mainclass ferret.core \
       --minimizejre soft \
       --output ferret

  mv ferret/jre/bin/msvcr100.dll ferret/
  zip -r ferret-windows-amd64.zip ferret/

  java -jar packr.jar \
       --platform mac \
       --jdk openjdk-1.7.0-u80-unofficial-macosx-x86_64-image.zip \
       --executable ferret \
       --classpath target/ferret.jar \
       --mainclass ferret.core \
       --minimizejre soft \
       --output ferret

  echo "DIR=\"\$( cd \"\$( dirname \"\${BASH_SOURCE[0]}\" )\" && pwd )\"" > ferret/ferret
  echo "\$DIR/Contents/MacOS/ferret" >> ferret/ferret
  chmod +x ferret/ferret
  zip -r ferret-macosx-x86_64.zip ferret/
  rm -r ferret/

  java -jar packr.jar \
       --platform linux64 \
       --jdk openjdk-1.7.0-u80-unofficial-linux-amd64-image.zip \
       --executable ferret \
       --classpath target/ferret.jar \
       --mainclass ferret.core \
       --minimizejre soft \
       --output ferret

  zip -r ferret-linux-amd64.zip ferret/
  rm -r ferret/

  rm packr.jar openjdk-1.7.0-u80-unofficial-macosx-x86_64-image.zip openjdk-1.7.0-u80-unofficial-linux-amd64-image.zip openjdk-1.7.0-u80-unofficial-windows-amd64-image.zip
#+end_src

*** ferret-mode.el

#+begin_src emacs-lisp :mkdirp yes :tangle src/resources/ferret-mode.el :padline no :results none
  (define-derived-mode ferret-mode
    clojure-mode "Ferret"
    "Major mode for Ferret.
  \\{ferret-mode-map}"

    (define-key ferret-mode-map (kbd "C-c '") 'ferret-indent-cpp)
    (define-key ferret-mode-map (kbd "C-c c") 'compile)

    (require 'compile)
    (require 'ansi-color)

    (defun ferret-colorize-compilation-buffer ()
      (toggle-read-only)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (toggle-read-only))
    
    (add-hook 'compilation-filter-hook 'ferret-colorize-compilation-buffer)
    
    (add-hook 'ferret-mode-hook
              (lambda ()
                (set (make-local-variable 'compile-command)
                     (let ((file (file-name-nondirectory buffer-file-name)))
                       (format "ferret -i %s" buffer-file-name)))))
    
    (defun ferret-indent-cpp ()
      (interactive)
      (let ((cursor-point (point)))
        (ignore-errors
         (let ((pps (parse-partial-sexp (point-min) (point))))
           (when (nth 3 pps)
             (let ((str-begin (nth 8 pps)))
               (goto-char str-begin)
               (forward-sexp)
               (backward-char)
               (let ((str-end (point)))
                 (goto-char str-begin)
                 (forward-char)
                 (set-mark str-end)))
             (let ((col (save-excursion (goto-char (region-beginning))
                                        (current-column))))
               (kill-region (region-beginning) (region-end))
               (insert
                (with-temp-buffer
                  (c++-mode)
                  (yank)
                  ;;un escape "
                  (goto-char (point-min))
                  (replace-string "\\\"" "\"")
                  (indent-region (point-min) (point-max) nil)
                  ;;escape "
                  (goto-char (point-min))
                  (replace-string "\"" "\\\"")
                  ;;select all but first line
                  (goto-char (point-min))
                  (forward-line)
                  (push-mark (point))
                  (push-mark (point-max) nil t)
                  ;;shift all text to col
                  (indent-rigidly (region-beginning) (region-end) col)
                  (buffer-string)))))))
        (goto-char cursor-point))))
#+end_src
